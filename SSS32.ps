%!PS-Adobe-3.0
%%Orientation: Portrait
%%Pages: 27
%%EndComments
%%BeginSetup
(SSS32)
(revision alpha-4.5)
[
(MIT License)
()
(Copyright (c) 2020 Blockstream)
()
(Permission is hereby granted, free of charge, to any person obtaining a copy)
(of this software and associated documentation files (the "Software"), to deal)
(in the Software without restriction, including without limitation the rights)
(to use, copy, modify, merge, publish, distribute, sublicense, and/or sell)
(copies of the Software, and to permit persons to whom the Software is)
(furnished to do so, subject to the following conditions:)
()
(The above copyright notice and this permission notice shall be included in all)
(copies or substantial portions of the Software.)
()
(THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR)
(IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,)
(FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE)
(AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER)
(LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,)
(OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE)
(SOFTWARE.)
]
[
(WARNING: Seriously, this is a work in progress, and it is only a concept right now.)
(If you try to use this for your valuable data, I promise you will lose your data.)
(You will lose this document and come back here only to find that I have made incompatible changes,)
(and your data is lost forever. Even if you don't lose this document, there is no warranty or)
(guarantee of any kind that you will be able to recover successfully recover your data.)
]
[
(MATERIALS: Scissors, X-Acto knife, brass fasteners)
()
(CONSTRUCTION:)
(The bottom discs are the discs with a small circle in the center of them.)
(The top discs are the discs with a small cross in the centre. All the top discs are identical. Cut out each disc.)
(Cut out the small centre circle in each the bottom discs. Cut out each of the 32 squares of each top disc.)
(Cut a slit along one one of the small lines of the cross in each of the top discs.)
(Pass the brass fastener through a top disc and bottom disc.)
(Fold the legs of the fastener apart to secure the top and bottom discs together.)
(The two discs should now be able to rotate about their common centre.)
()
(SECRET RECOVERY:)
(Find 2 of your secured shares.)
(Make sure all your shares have the same identifier and a valid checksum (see checksum worksheet).)
(Dial the recover share disc to the share index of the first secured share (the 5th character).)
(Look up the symbol associated with the share index of the other share.)
(Set your translation disc to that symbol and translate the first secured share by looking up every charater in turn.)
(Dial the recover share disc to the share index of the second secured share (the 5th character).)
(Look up the symbol associated with the share index of the first share.)
(Set your translation disc to that symbol and translate the second secured share by looking up every charater in turn.)
(Add the two translated shares, character by character, using the Addition disc.)
(The result is your secret share and will have share index S and a valid checksum.)
]
/README exch def
/warning exch def
/MIT exch def
/ver exch def
/name exch def

/pgsize currentpagedevice /PageSize known
  { currentpagedevice /PageSize get
  } {
    [611.842163 791.842163] % letter size
  } ifelse
def
/magic 94 def % a magic angle for making nice looking spirals.
/code (QPZRY9X8GF2TVDW0S3JN54KHCE6MUA7L ) def
/code2 (\264\300abcdefghijklmnopqrstuvwxyz\247\250\251\252 ) def
/perm [29 24 13 25 9 8 23 18 22 31 27 19 1 0 3 16 11 28 12 14 6 4 2 15 10 17 21 20 26 30 7 5 ] def
/permS [16 29 24 13 25 9 8 23 18 22 31 27 19 1 0 3 11 28 12 14 6 4 2 15 10 17 21 20 26 30 7 5 ] def
/permV [22 11 10 29 31 28 17 24 27 12 21 13 19 14 20 25 1 6 26 9 0 4 30 8 3 2 7 23 16 15 5 18 ] def
/permP [0 1 2 4 8 16 9 18 13 26 29 19 15 30 21 3 6 12 24 25 27 31 23 7 14 28 17 11 22 5 10 20] def
% Generator for GF(32) is alpha^5 = alpha^3 + 1

/gf32add % x y -> x [+] y where [+] is addition in GF32.
         % returns 32 if x or y is out of range.
         % Note that x [+] y = x [-] y in GF32.
{               % x y
 2 copy 32 ge   % x y x (y >= 32)
 exch 32 ge or  % x y (y >= 32 || x >= 32)
 {pop pop 32}     % 32
 {xor}            % x [+] y
 ifelse         % if (y >= 32 || x >= 32) then 32 else (x [+] y)
} bind def

/gf32mulalpha % x -> x [*] alpha where [*] is multiplicaiton in GF32 and alpha is represted by 0b00010.
{               % x
 2 mul          % 2*x
 dup 32 ge      % 2*x (2*x >= 0b100000)
 { 41 xor }       % 2*x `xor` 0b101001
 if             % if (2*x >= 0xb100000) then 2*x `xor` 0x0b101001 else 2*x
} bind def

/gf32mul % x y -> x [*] y where [*] is multiplication in GF32.
         % returns 32 if x or y is out of range.
{                % x y
 10 dict begin
 { /y /x } {exch def} forall
 x 32 ge y 32 ge or  % (y >= 32 || x >= 32)
 {32}                  % 32
 {
   /xShift x def
   /yAlpha y def
   0                   % 0
   5 {                                % ((x & 0b001..1) [*] y) (x >> i) (y [*] alpha[^i])
     xShift 1 and yAlpha mul xor      % ((x & 0b001..1) [*] y [+] ((x >> i) & 1) * (y [*] alpha [^i]))
     /xShift xShift -1 bitshift def
     /yAlpha yAlpha gf32mulalpha def
   } repeat            % ((x & 0b11111) [*] y)
 } ifelse            % if (y >= 32 || x >= 32) then 32 else (x [*] y)
 end
} bind def

/gf32inv % x -> x [^-1] where [^-1] is the inverse operation in GF32.
         % returns 0 when given 0.
         % returns 32 if x is out of range.
{                        % x
 dup dup gf32mul         % x x[^2]
 dup gf32mul gf32mul     % x[^5]
 dup dup gf32mul gf32mul % x[^15]
 dup gf32mul             % x[^30]
                         % x[^-1]
} bind def

/lagrange % x xj [x[0] .. x[k]] -> l[j](x)
          % returns the lagrange basis polynomial l[j] evaluated at x for interpolation of coordinates [x[0] .. x[k]].
          % Requires xj `elem` [x[0] ... x[k]]
{               % x xj [x[0] .. x[k]]
 10 dict begin
 { /xs /xj /x } {exch def} forall
 1 xs           % 1 [x[0] .. x[k]]
 {                % let P = product [(x [-] x[m]) [/] (xj [-] x[m]) | m <- [0..i-1], x[m] /= xj]
                  % P x[i]
   /xi exch def   % P
   xi xj gf32add  % P (xj [-] x[i])
   dup 0 eq       % P (xj [-] x[i]) (xj [-] x[i] == 0)
   { pop }                 % P
   { gf32inv gf32mul       % (P [/] (xj [-] x[i])
     xi x gf32add gf32mul  % (P [*] (x [-] x[i]) [/] (xj [-] x[i]))
   }
   ifelse         % (if xj == x[i] then P else (P [*] (x [-] x[i]) [/] (xj [-] x[i]))
 } forall       % x xj (product [(x [-] x[m]) [/] (xj [-] x[m]) | m <- [0..k], x[m] /= xj])
 end
} bind def

/makeShare % sS sA i -> si
       { 3 2 roll 1 index permS 0 get permS 0 2 getinterval lagrange gf32mul
         3 1 roll permS 1 get permS 0 2 getinterval lagrange gf32mul
         xor
       } bind def

/gf32mularray % x b -> x * b
  { [ 3 1 roll { 1 index gf32mul exch } forall pop ]
  } bind def

/gf32addarray % a b -> a + b pointwise
  { [ 3 1 roll 0 1 2 index length 1 sub { 2 index 1 index get 2 index 2 index get gf32add exch pop 3 1 roll } for pop pop ]
  } bind def

/polymodulus [31 5 3 28 0 31 31 31 9 5 30 2 2] def % coefficents from c12 to c0
/checksum [16 25 24 3 25 11 16 23 29 3 25 17 10] def
/checksumstring { polymodulus length string checksum 0 1 polymodulus length 1 sub {3 copy exch 1 index get code exch 1 getinterval putinterval pop } for pop } bind def

/polymod0 % array -> [ c5 c4 c3 c2 c1 c0 ]
 { [ polymodulus length {0} repeat ]
   exch
   { [ exch 2 index 1 polymodulus length 1 sub getinterval aload pop polymodulus length dup 1 sub roll ] exch 0 get polymodulus gf32mularray gf32addarray  } forall
 } bind def

/polymodshift2 % c7 c6 -> [ c5 c4 c3 c2 c1 c0 ]
 {  [ 3 1 roll polymodulus length {0} repeat ] polymod0
 } bind def

/polymodhrp % string -> [ c5 c4 c3 c2 c1 c0 ]
 {
   [ exch 1 exch dup { 32 idiv exch } forall 0 exch { 31 and } forall ] polymod0
 } bind def

/underlineshow {
    dup dup (6) eq exch (9) eq or { % if the string is (6) or (9)
        gsave (_) show grestore % draw an underline
    } if
    show
} bind def
/centreshow {dup stringwidth pop 2 div neg 0 rmoveto underlineshow} bind def
/centresquare {dup neg 2 div dup rmoveto dup 0 rlineto dup 0 exch rlineto neg 0 rlineto closepath stroke} bind def
/concatstrings % (a) (b) -> (ab)
   { exch dup length
     2 index length add string
     dup dup 4 2 roll copy length
     4 -1 roll putinterval
   } bind def

% From BLUEBOOK Program #10
/outsidecircletext
  { circtextdict begin
      /radius exch def
      /centerangle exch def
      /ptsize exch def
      /str exch def
      /xradius radius ptsize 4 div add def

      gsave
        centerangle str findhalfangle add rotate

        str
          { /charcode exch def
            ( ) dup 0 charcode put outsideplacechar
          } forall
      grestore
    end
  } def

/insidecircletext
{ circtextdict begin
  /radius exch def /centerangle exch def
  /ptsize exch def /str exch def
  /xradius radius ptsize 3 div sub def
  gsave
   centerangle str findhalfangle sub rotate
   str
    { /charcode exch def
      ( ) dup 0 charcode put insideplacechar
    } forall
  grestore
  end
} def

/circtextdict 16 dict def
circtextdict begin
 /findhalfangle
  { stringwidth pop 2 div
    2 xradius mul pi mul div 360 mul
  } def

/outsideplacechar
    { /char exch def
      /halfangle char findhalfangle def
      gsave
        halfangle neg rotate
        radius 0 translate
        -90 rotate
        char stringwidth pop 2 div neg 0 moveto
        char show
      grestore
      halfangle 2 mul neg rotate
    } def

/insideplacechar
 { /char exch def
   /halfangle char findhalfangle def
   gsave
    halfangle rotate
    radius 0 translate
    90 rotate
    char stringwidth pop 2 div neg 0 moveto
    char show
   grestore
   halfangle 2 mul rotate
 } def

/pi 3.1415923 def
end

/drawBottomWheelPage
 { 10 dict begin
   /outerperm exch def
   /outercode exch def
   /outerfont exch def
   /innercode exch def
   /innerfont exch def
   /title exch def
   /binop exch def
   /angle 360 outerperm length div neg def
   % Move cursor to center of page
   pgsize aload pop 2 div exch 2 div exch translate
   % Draw white interior circle
   newpath 0 0 6 40 mul 0 360 arc stroke
   newpath 0 0 6 40 mul 28 add 0 360 arc stroke
   newpath 0 0 6 0 360 arc stroke
   % Draw title (small text, repeated)
   /Helvetica findfont 12 scalefont setfont
   title 12 270 30 insidecircletext
   % Draw letters (using human-centric ABCD... permutation)
   /Helvetica findfont 6 scalefont setfont
   gsave
   360 16 div 360 64 div sub rotate
   0 360 8 div 360 {title 6 3 -1 roll 262 outsidecircletext} for
   grestore
   outerfont findfont 18 scalefont setfont
   outerperm {0 38 sqrt 40 mul moveto outercode exch 1 getinterval centreshow angle rotate} forall
   % Draw inside contents
   innerfont findfont 12 scalefont setfont
   180 rotate
   0 1 31 { % Draw 32 circles of increasing radius
       magic rotate
       outerperm {
           0 2 index 2 add sqrt 40 mul moveto % move to 0, 2.5 + 40*sqrt(outer index + 2)
           1 index 31 exch sub % 31 - inner index
           permV exch get binop % apply binary operation to the permuted letter and the inner index
           innercode exch 1 getinterval centreshow % display the result
           angle rotate % rotate one entry
       } forall pop
   } for
   end
 } bind def

/showTopWheelPage
 {
   % Move cursor to center of page
   pgsize aload pop 2 div exch 2 div exch translate
   % Draw gray "handle" and white interior circle
   0.8 setgray
   newpath 0 0 7.25 40 mul 140 40 arc fill
   1 setgray
   newpath 0 0 6 40 mul 0 360 arc fill
   0 setgray
   newpath 0 0 6 40 mul 0 360 arc stroke
   % Draw centre cross
   newpath 0 6 moveto 0 -6 lineto stroke
   newpath 6 0 moveto -6 0 lineto stroke
   % Draw indicator arrow
   newpath 0 6 40 mul moveto 10 -20 rlineto -20 0 rlineto closepath fill
   % Draw text
   /Courier findfont 12 scalefont setfont
   180 rotate
   0 1 31 {
       magic rotate
       dup 2 add sqrt 40 mul 2.5 add % lam = 2.5 + 40*sqrt(idx + 2)
       newpath
       0 exch % set midpoint: 0 lam
       2 copy moveto
       12 centresquare % draw square
       moveto % return to midpoint
       -26 -3 rmoveto % Move to the left
       31 exch sub % 31 - loop index
       permV exch get code exch 1 getinterval % Permute index and extract 1-char substring of alphabet
       /Courier findfont 12 scalefont setfont underlineshow % ...and draw it
       (\256) /Symbol findfont 12 scalefont setfont show % Draw a right arrow
   } for
 } bind def

/showShareTable {
/offsety exch def
/offsetx exch def
/page exch def
/Courier findfont 10 scalefont setfont
20 offsetx add offsety moveto (Page: ) show
/Courier-Bold findfont 8 scalefont setfont
code page 1 getinterval show
2 1 31 {
dup 7 mul offsetx add offsety 10 sub moveto
permS exch get
code exch 1 getinterval show
} for

0 1 31 {
/Courier-Bold findfont 8 scalefont setfont
offsetx offsety 20 sub 2 index 8 mul sub moveto
dup code exch perm exch get 1 getinterval show
/Courier findfont 8 scalefont setfont
2 1 31 {
dup 7 mul offsetx add offsety 20 sub 3 index 8 mul sub moveto
permS exch get
page exch perm 3 index get exch  makeShare code exch 1 getinterval show
} for pop } for
} bind def

/showShareTablePage {
325 400 showShareTable
50 400 showShareTable
325 720 showShareTable
50 720 showShareTable
} bind def

/arraySpace 13 def
/gapSpace arraySpace 2 add def
/showArray {
  10 dict begin
  { /n /spaces /word } {exch def} forall
  spaces length string
  0 1 spaces length 1 sub
    { 2 copy code word n get 1 getinterval putinterval pop
      /n n 1 add def
    } for
  spaces xshow
  end
} bind def

/showBox {
  10 dict begin
  { /n /spaces /word /decoration } {exch def} forall
  spaces { gsave n decoration grestore
      0 rmoveto
      /n n 1 add def
    } forall
  end
} bind def

/showArrayBox {
  4 copy gsave showBox grestore
  showArray pop
} bind def

/showParagraphs {
  10 dict begin
  { /paragraphs /height /width } {exch def} forall
  paragraphs {
    /lines exch def
    lines 0 lines length 1 sub getinterval {
      /line exch def
      % Compute amount of space needed for each /space character
      width line stringwidth pop sub 0 line { 32 eq { 1 add } if} forall div
      0 32 line gsave widthshow grestore
      0 height neg rmoveto
    } forall
    lines lines length 1 sub get gsave show grestore
    0 height neg 2 mul rmoveto
  } forall
  end
} bind def

/bip39words [
    (aban) (abil) (able) (abou) (abov) (abse) (abso) (abst) (absu) (abus) (acce) (acci) (acco) (accu) (achi) (acid)
    (acou) (acqu) (acro) (act ) (acti) (acto) (actr) (actu) (adap) (add ) (addi) (addr) (adju) (admi) (adul) (adva)
    (advi) (aero) (affa) (affo) (afra) (agai) (age ) (agen) (agre) (ahea) (aim ) (air ) (airp) (aisl) (alar) (albu)
    (alco) (aler) (alie) (all ) (alle) (allo) (almo) (alon) (alph) (alre) (also) (alte) (alwa) (amat) (amaz) (amon)
    (amou) (amus) (anal) (anch) (anci) (ange) (angl) (angr) (anim) (ankl) (anno) (annu) (anot) (answ) (ante) (anti)
    (anxi) (any ) (apar) (apol) (appe) (appl) (appr) (apri) (arch) (arct) (area) (aren) (argu) (arm ) (arme) (armo)
    (army) (arou) (arra) (arre) (arri) (arro) (art ) (arte) (arti) (artw) (ask ) (aspe) (assa) (asse) (assi) (assu)
    (asth) (athl) (atom) (atta) (atte) (atti) (attr) (auct) (audi) (augu) (aunt) (auth) (auto) (autu) (aver) (avoc)
    (avoi) (awak) (awar) (away) (awes) (awfu) (awkw) (axis) (baby) (bach) (baco) (badg) (bag ) (bala) (balc) (ball)
    (bamb) (bana) (bann) (bar ) (bare) (barg) (barr) (base) (basi) (bask) (batt) (beac) (bean) (beau) (beca) (beco)
    (beef) (befo) (begi) (beha) (behi) (beli) (belo) (belt) (benc) (bene) (best) (betr) (bett) (betw) (beyo) (bicy)
    (bid ) (bike) (bind) (biol) (bird) (birt) (bitt) (blac) (blad) (blam) (blan) (blas) (blea) (bles) (blin) (bloo)
    (blos) (blou) (blue) (blur) (blus) (boar) (boat) (body) (boil) (bomb) (bone) (bonu) (book) (boos) (bord) (bori)
    (borr) (boss) (bott) (boun) (box ) (boy ) (brac) (brai) (bran) (bras) (brav) (brea) (bree) (bric) (brid) (brie)
    (brig) (brin) (bris) (broc) (brok) (bron) (broo) (brot) (brow) (brus) (bubb) (budd) (budg) (buff) (buil) (bulb)
    (bulk) (bull) (bund) (bunk) (burd) (burg) (burs) (bus ) (busi) (busy) (butt) (buye) (buzz) (cabb) (cabi) (cabl)
    (cact) (cage) (cake) (call) (calm) (came) (camp) (can ) (cana) (canc) (cand) (cann) (cano) (canv) (cany) (capa)
    (capi) (capt) (car ) (carb) (card) (carg) (carp) (carr) (cart) (case) (cash) (casi) (cast) (casu) (cat ) (cata)
    (catc) (cate) (catt) (caug) (caus) (caut) (cave) (ceil) (cele) (ceme) (cens) (cent) (cere) (cert) (chai) (chal)
    (cham) (chan) (chao) (chap) (char) (chas) (chat) (chea) (chec) (chee) (chef) (cher) (ches) (chic) (chie) (chil)
    (chim) (choi) (choo) (chro) (chuc) (chun) (chur) (ciga) (cinn) (circ) (citi) (city) (civi) (clai) (clap) (clar)
    (claw) (clay) (clea) (cler) (clev) (clic) (clie) (clif) (clim) (clin) (clip) (cloc) (clog) (clos) (clot) (clou)
    (clow) (club) (clum) (clus) (clut) (coac) (coas) (coco) (code) (coff) (coil) (coin) (coll) (colo) (colu) (comb)
    (come) (comf) (comi) (comm) (comp) (conc) (cond) (conf) (cong) (conn) (cons) (cont) (conv) (cook) (cool) (copp)
    (copy) (cora) (core) (corn) (corr) (cost) (cott) (couc) (coun) (coup) (cour) (cous) (cove) (coyo) (crac) (crad)
    (craf) (cram) (cran) (cras) (crat) (craw) (craz) (crea) (cred) (cree) (crew) (cric) (crim) (cris) (crit) (crop)
    (cros) (crou) (crow) (cruc) (crue) (crui) (crum) (crun) (crus) (cry ) (crys) (cube) (cult) (cup ) (cupb) (curi)
    (curr) (curt) (curv) (cush) (cust) (cute) (cycl) (dad ) (dama) (damp) (danc) (dang) (dari) (dash) (daug) (dawn)
    (day ) (deal) (deba) (debr) (deca) (dece) (deci) (decl) (deco) (decr) (deer) (defe) (defi) (defy) (degr) (dela)
    (deli) (dema) (demi) (deni) (dent) (deny) (depa) (depe) (depo) (dept) (depu) (deri) (desc) (dese) (desi) (desk)
    (desp) (dest) (deta) (dete) (deve) (devi) (devo) (diag) (dial) (diam) (diar) (dice) (dies) (diet) (diff) (digi)
    (dign) (dile) (dinn) (dino) (dire) (dirt) (disa) (disc) (dise) (dish) (dism) (diso) (disp) (dist) (dive) (divi)
    (divo) (dizz) (doct) (docu) (dog ) (doll) (dolp) (doma) (dona) (donk) (dono) (door) (dose) (doub) (dove) (draf)
    (drag) (dram) (dras) (draw) (drea) (dres) (drif) (dril) (drin) (drip) (driv) (drop) (drum) (dry ) (duck) (dumb)
    (dune) (duri) (dust) (dutc) (duty) (dwar) (dyna) (eage) (eagl) (earl) (earn) (eart) (easi) (east) (easy) (echo)
    (ecol) (econ) (edge) (edit) (educ) (effo) (egg ) (eigh) (eith) (elbo) (elde) (elec) (eleg) (elem) (elep) (elev)
    (elit) (else) (emba) (embo) (embr) (emer) (emot) (empl) (empo) (empt) (enab) (enac) (end ) (endl) (endo) (enem)
    (ener) (enfo) (enga) (engi) (enha) (enjo) (enli) (enou) (enri) (enro) (ensu) (ente) (enti) (entr) (enve) (epis)
    (equa) (equi) (era ) (eras) (erod) (eros) (erro) (erup) (esca) (essa) (esse) (esta) (eter) (ethi) (evid) (evil)
    (evok) (evol) (exac) (exam) (exce) (exch) (exci) (excl) (excu) (exec) (exer) (exha) (exhi) (exil) (exis) (exit)
    (exot) (expa) (expe) (expi) (expl) (expo) (expr) (exte) (extr) (eye ) (eyeb) (fabr) (face) (facu) (fade) (fain)
    (fait) (fall) (fals) (fame) (fami) (famo) (fan ) (fanc) (fant) (farm) (fash) (fat ) (fata) (fath) (fati) (faul)
    (favo) (feat) (febr) (fede) (fee ) (feed) (feel) (fema) (fenc) (fest) (fetc) (feve) (few ) (fibe) (fict) (fiel)
    (figu) (file) (film) (filt) (fina) (find) (fine) (fing) (fini) (fire) (firm) (firs) (fisc) (fish) (fit ) (fitn)
    (fix ) (flag) (flam) (flas) (flat) (flav) (flee) (flig) (flip) (floa) (floc) (floo) (flow) (flui) (flus) (fly )
    (foam) (focu) (fog ) (foil) (fold) (foll) (food) (foot) (forc) (fore) (forg) (fork) (fort) (foru) (forw) (foss)
    (fost) (foun) (fox ) (frag) (fram) (freq) (fres) (frie) (frin) (frog) (fron) (fros) (frow) (froz) (frui) (fuel)
    (fun ) (funn) (furn) (fury) (futu) (gadg) (gain) (gala) (gall) (game) (gap ) (gara) (garb) (gard) (garl) (garm)
    (gas ) (gasp) (gate) (gath) (gaug) (gaze) (gene) (geni) (genr) (gent) (genu) (gest) (ghos) (gian) (gift) (gigg)
    (ging) (gira) (girl) (give) (glad) (glan) (glar) (glas) (glid) (glim) (glob) (gloo) (glor) (glov) (glow) (glue)
    (goat) (godd) (gold) (good) (goos) (gori) (gosp) (goss) (gove) (gown) (grab) (grac) (grai) (gran) (grap) (gras)
    (grav) (grea) (gree) (grid) (grie) (grit) (groc) (grou) (grow) (grun) (guar) (gues) (guid) (guil) (guit) (gun )
    (gym ) (habi) (hair) (half) (hamm) (hams) (hand) (happ) (harb) (hard) (hars) (harv) (hat ) (have) (hawk) (haza)
    (head) (heal) (hear) (heav) (hedg) (heig) (hell) (helm) (help) (hen ) (hero) (hidd) (high) (hill) (hint) (hip )
    (hire) (hist) (hobb) (hock) (hold) (hole) (holi) (holl) (home) (hone) (hood) (hope) (horn) (horr) (hors) (hosp)
    (host) (hote) (hour) (hove) (hub ) (huge) (huma) (humb) (humo) (hund) (hung) (hunt) (hurd) (hurr) (hurt) (husb)
    (hybr) (ice ) (icon) (idea) (iden) (idle) (igno) (ill ) (ille) (illn) (imag) (imit) (imme) (immu) (impa) (impo)
    (impr) (impu) (inch) (incl) (inco) (incr) (inde) (indi) (indo) (indu) (infa) (infl) (info) (inha) (inhe) (init)
    (inje) (inju) (inma) (inne) (inno) (inpu) (inqu) (insa) (inse) (insi) (insp) (inst) (inta) (inte) (into) (inve)
    (invi) (invo) (iron) (isla) (isol) (issu) (item) (ivor) (jack) (jagu) (jar ) (jazz) (jeal) (jean) (jell) (jewe)
    (job ) (join) (joke) (jour) (joy ) (judg) (juic) (jump) (jung) (juni) (junk) (just) (kang) (keen) (keep) (ketc)
    (key ) (kick) (kid ) (kidn) (kind) (king) (kiss) (kit ) (kitc) (kite) (kitt) (kiwi) (knee) (knif) (knoc) (know)
    (lab ) (labe) (labo) (ladd) (lady) (lake) (lamp) (lang) (lapt) (larg) (late) (lati) (laug) (laun) (lava) (law )
    (lawn) (laws) (laye) (lazy) (lead) (leaf) (lear) (leav) (lect) (left) (leg ) (lega) (lege) (leis) (lemo) (lend)
    (leng) (lens) (leop) (less) (lett) (leve) (liar) (libe) (libr) (lice) (life) (lift) (ligh) (like) (limb) (limi)
    (link) (lion) (liqu) (list) (litt) (live) (liza) (load) (loan) (lobs) (loca) (lock) (logi) (lone) (long) (loop)
    (lott) (loud) (loun) (love) (loya) (luck) (lugg) (lumb) (luna) (lunc) (luxu) (lyri) (mach) (mad ) (magi) (magn)
    (maid) (mail) (main) (majo) (make) (mamm) (man ) (mana) (mand) (mang) (mans) (manu) (mapl) (marb) (marc) (marg)
    (mari) (mark) (marr) (mask) (mass) (mast) (matc) (mate) (math) (matr) (matt) (maxi) (maze) (mead) (mean) (meas)
    (meat) (mech) (meda) (medi) (melo) (melt) (memb) (memo) (ment) (menu) (merc) (merg) (meri) (merr) (mesh) (mess)
    (meta) (meth) (midd) (midn) (milk) (mill) (mimi) (mind) (mini) (mino) (minu) (mira) (mirr) (mise) (miss) (mist)
    (mix ) (mixe) (mixt) (mobi) (mode) (modi) (mom ) (mome) (moni) (monk) (mons) (mont) (moon) (mora) (more) (morn)
    (mosq) (moth) (moti) (moto) (moun) (mous) (move) (movi) (much) (muff) (mule) (mult) (musc) (muse) (mush) (musi)
    (must) (mutu) (myse) (myst) (myth) (naiv) (name) (napk) (narr) (nast) (nati) (natu) (near) (neck) (need) (nega)
    (negl) (neit) (neph) (nerv) (nest) (net ) (netw) (neut) (neve) (news) (next) (nice) (nigh) (nobl) (nois) (nomi)
    (nood) (norm) (nort) (nose) (nota) (note) (noth) (noti) (nove) (now ) (nucl) (numb) (nurs) (nut ) (oak ) (obey)
    (obje) (obli) (obsc) (obse) (obta) (obvi) (occu) (ocea) (octo) (odor) (off ) (offe) (offi) (ofte) (oil ) (okay)
    (old ) (oliv) (olym) (omit) (once) (one ) (onio) (onli) (only) (open) (oper) (opin) (oppo) (opti) (oran) (orbi)
    (orch) (orde) (ordi) (orga) (orie) (orig) (orph) (ostr) (othe) (outd) (oute) (outp) (outs) (oval) (oven) (over)
    (own ) (owne) (oxyg) (oyst) (ozon) (pact) (padd) (page) (pair) (pala) (palm) (pand) (pane) (pani) (pant) (pape)
    (para) (pare) (park) (parr) (part) (pass) (patc) (path) (pati) (patr) (patt) (paus) (pave) (paym) (peac) (pean)
    (pear) (peas) (peli) (pen ) (pena) (penc) (peop) (pepp) (perf) (perm) (pers) (pet ) (phon) (phot) (phra) (phys)
    (pian) (picn) (pict) (piec) (pig ) (pige) (pill) (pilo) (pink) (pion) (pipe) (pist) (pitc) (pizz) (plac) (plan)
    (plas) (plat) (play) (plea) (pled) (pluc) (plug) (plun) (poem) (poet) (poin) (pola) (pole) (poli) (pond) (pony)
    (pool) (popu) (port) (posi) (poss) (post) (pota) (pott) (pove) (powd) (powe) (prac) (prai) (pred) (pref) (prep)
    (pres) (pret) (prev) (pric) (prid) (prim) (prin) (prio) (pris) (priv) (priz) (prob) (proc) (prod) (prof) (prog)
    (proj) (prom) (proo) (prop) (pros) (prot) (prou) (prov) (publ) (pudd) (pull) (pulp) (puls) (pump) (punc) (pupi)
    (pupp) (purc) (puri) (purp) (purs) (push) (put ) (puzz) (pyra) (qual) (quan) (quar) (ques) (quic) (quit) (quiz)
    (quot) (rabb) (racc) (race) (rack) (rada) (radi) (rail) (rain) (rais) (rall) (ramp) (ranc) (rand) (rang) (rapi)
    (rare) (rate) (rath) (rave) (raw ) (razo) (read) (real) (reas) (rebe) (rebu) (reca) (rece) (reci) (reco) (recy)
    (redu) (refl) (refo) (refu) (regi) (regr) (regu) (reje) (rela) (rele) (reli) (rely) (rema) (reme) (remi) (remo)
    (rend) (rene) (rent) (reop) (repa) (repe) (repl) (repo) (requ) (resc) (rese) (resi) (reso) (resp) (resu) (reti)
    (retr) (retu) (reun) (reve) (revi) (rewa) (rhyt) (rib ) (ribb) (rice) (rich) (ride) (ridg) (rifl) (righ) (rigi)
    (ring) (riot) (ripp) (risk) (ritu) (riva) (rive) (road) (roas) (robo) (robu) (rock) (roma) (roof) (rook) (room)
    (rose) (rota) (roug) (roun) (rout) (roya) (rubb) (rude) (rug ) (rule) (run ) (runw) (rura) (sad ) (sadd) (sadn)
    (safe) (sail) (sala) (salm) (salo) (salt) (salu) (same) (samp) (sand) (sati) (sato) (sauc) (saus) (save) (say )
    (scal) (scan) (scar) (scat) (scen) (sche) (scho) (scie) (scis) (scor) (scou) (scra) (scre) (scri) (scru) (sea )
    (sear) (seas) (seat) (seco) (secr) (sect) (secu) (seed) (seek) (segm) (sele) (sell) (semi) (seni) (sens) (sent)
    (seri) (serv) (sess) (sett) (setu) (seve) (shad) (shaf) (shal) (shar) (shed) (shel) (sher) (shie) (shif) (shin)
    (ship) (shiv) (shoc) (shoe) (shoo) (shop) (shor) (shou) (shov) (shri) (shru) (shuf) (shy ) (sibl) (sick) (side)
    (sieg) (sigh) (sign) (sile) (silk) (sill) (silv) (simi) (simp) (sinc) (sing) (sire) (sist) (situ) (six ) (size)
    (skat) (sket) (ski ) (skil) (skin) (skir) (skul) (slab) (slam) (slee) (slen) (slic) (slid) (slig) (slim) (slog)
    (slot) (slow) (slus) (smal) (smar) (smil) (smok) (smoo) (snac) (snak) (snap) (snif) (snow) (soap) (socc) (soci)
    (sock) (soda) (soft) (sola) (sold) (soli) (solu) (solv) (some) (song) (soon) (sorr) (sort) (soul) (soun) (soup)
    (sour) (sout) (spac) (spar) (spat) (spaw) (spea) (spec) (spee) (spel) (spen) (sphe) (spic) (spid) (spik) (spin)
    (spir) (spli) (spoi) (spon) (spoo) (spor) (spot) (spra) (spre) (spri) (spy ) (squa) (sque) (squi) (stab) (stad)
    (staf) (stag) (stai) (stam) (stan) (star) (stat) (stay) (stea) (stee) (stem) (step) (ster) (stic) (stil) (stin)
    (stoc) (stom) (ston) (stoo) (stor) (stov) (stra) (stre) (stri) (stro) (stru) (stud) (stuf) (stum) (styl) (subj)
    (subm) (subw) (succ) (such) (sudd) (suff) (suga) (sugg) (suit) (summ) (sun ) (sunn) (suns) (supe) (supp) (supr)
    (sure) (surf) (surg) (surp) (surr) (surv) (susp) (sust) (swal) (swam) (swap) (swar) (swea) (swee) (swif) (swim)
    (swin) (swit) (swor) (symb) (symp) (syru) (syst) (tabl) (tack) (tag ) (tail) (tale) (talk) (tank) (tape) (targ)
    (task) (tast) (tatt) (taxi) (teac) (team) (tell) (ten ) (tena) (tenn) (tent) (term) (test) (text) (than) (that)
    (them) (then) (theo) (ther) (they) (thin) (this) (thou) (thre) (thri) (thro) (thum) (thun) (tick) (tide) (tige)
    (tilt) (timb) (time) (tiny) (tip ) (tire) (tiss) (titl) (toas) (toba) (toda) (todd) (toe ) (toge) (toil) (toke)
    (toma) (tomo) (tone) (tong) (toni) (tool) (toot) (top ) (topi) (topp) (torc) (torn) (tort) (toss) (tota) (tour)
    (towa) (towe) (town) (toy ) (trac) (trad) (traf) (trag) (trai) (tran) (trap) (tras) (trav) (tray) (trea) (tree)
    (tren) (tria) (trib) (tric) (trig) (trim) (trip) (trop) (trou) (truc) (true) (trul) (trum) (trus) (trut) (try )
    (tube) (tuit) (tumb) (tuna) (tunn) (turk) (turn) (turt) (twel) (twen) (twic) (twin) (twis) (two ) (type) (typi)
    (ugly) (umbr) (unab) (unaw) (uncl) (unco) (unde) (undo) (unfa) (unfo) (unha) (unif) (uniq) (unit) (univ) (unkn)
    (unlo) (unti) (unus) (unve) (upda) (upgr) (upho) (upon) (uppe) (upse) (urba) (urge) (usag) (use ) (used) (usef)
    (usel) (usua) (util) (vaca) (vacu) (vagu) (vali) (vall) (valv) (van ) (vani) (vapo) (vari) (vast) (vaul) (vehi)
    (velv) (vend) (vent) (venu) (verb) (veri) (vers) (very) (vess) (vete) (viab) (vibr) (vici) (vict) (vide) (view)
    (vill) (vint) (viol) (virt) (viru) (visa) (visi) (visu) (vita) (vivi) (voca) (voic) (void) (volc) (volu) (vote)
    (voya) (wage) (wago) (wait) (walk) (wall) (waln) (want) (warf) (warm) (warr) (wash) (wasp) (wast) (wate) (wave)
    (way ) (weal) (weap) (wear) (weas) (weat) (web ) (wedd) (week) (weir) (welc) (west) (wet ) (whal) (what) (whea)
    (whee) (when) (wher) (whip) (whis) (wide) (widt) (wife) (wild) (will) (win ) (wind) (wine) (wing) (wink) (winn)
    (wint) (wire) (wisd) (wise) (wish) (witn) (wolf) (woma) (wond) (wood) (wool) (word) (work) (worl) (worr) (wort)
    (wrap) (wrec) (wres) (wris) (writ) (wron) (yard) (year) (yell) (you ) (youn) (yout) (zebr) (zero) (zone) (zoo )
] def

/showbinary39 {
    16 dict begin
    /num exch def

    bip39words num get show
    ( ) show

    /sc 1 def
    1 1 11 { pop /sc sc 2 mul def } for
    1 1 11 {
        /sc sc 2 idiv def
        num sc and 0 eq {(0)} {(1)} ifelse show
    } for

    end
} bind def

/showbinaries39 {
    /Courier findfont 8 scalefont setfont

    16 dict begin
    /swap exch def
    /offset exch def
    /xstart exch def

    0 1 63 {
        dup
        8 mul 560 sub xstart exch moveto

        offset exch sub
        dup 256 mod 0 eq {
            /Courier-bold findfont 8 scalefont setfont
            showbinary39
            /Courier findfont 8 scalefont setfont
        } {
            showbinary39
        } ifelse
    } for

    end
} bind def
%%EndSetup

%%Page: 1 1
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
/Helvetica findfont 6 scalefont setfont
40 750 moveto
MIT {gsave ((c)) search {show pop /copyright glyphshow} if show grestore 0 -8 rmoveto} forall
/Helvetica findfont 20 scalefont setfont
0 -22 rmoveto
gsave name show grestore 0 -12 rmoveto
/Helvetica findfont 10 scalefont setfont
gsave ver show grestore 0 -16 rmoveto
/Helvetica findfont 6 scalefont setfont
warning {gsave show grestore 0 -7 rmoveto} forall
0 -16 rmoveto
/Helvetica findfont 8 scalefont setfont
README {gsave show grestore 0 -10 rmoveto} forall
pgsave restore
showpage

%%Page: 2 2
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
10 dict begin
  250 450
  /offsety exch def
  /offsetx exch def
  /Helvetica findfont 15 scalefont setfont
  20 offsetx add offsety moveto (Multiplication Table) show
  1 1 31 {
    /Symbol findfont 8 scalefont setfont
    offsetx 34.5 7 mul add offsety 5 sub 2 index 8 mul sub moveto
    dup code2 exch 1 getinterval show
    /Symbol findfont 8 scalefont setfont
    dup 1 31 {
    dup 2 add 7 mul offsetx add offsety 5 sub 3 index 8 mul sub moveto
    1 index gf32mul code2 exch 1 getinterval show
  } for pop } for
end

10 dict begin
%cat <<EOF | tbl | groff -Tps
%Dice Tables
%
%1d4;1d8
%.TS
%box;
%cFCW || cFCW | cFCW | cFCW | cFCW | cFCW | cFCW | cFCW | cFCW.
%        1       2       3       4       5       6       7       8
%=
%1       Q       P       Z       R       Y       9       X       8
%_
%2       G       F       2       T       V       D       W       0
%_
%3       S       3       J       N       5       4       K       H
%_
%4       C       E       6       M       U       A       7       L
%.TE
%
%2d6
%.TS
%box;
%cFCW || cFCW | cFCW | cFCW | cFCW | cFCW | cFCW.
%        1       2       3       4       5       6
%=
%1               Q       P       Z       R
%_
%2       Y       9       X       8       G       F
%_
%3       2       T       V       D       W       0
%_
%4       S       3       J       N       5       4
%_
%5       K       H       C       E       6       M
%_
%6               U       A       7       L
%.TE
%EOF
/SC 32 def
/E{0 rmoveto show}bind def
/G{0 rmoveto 0 exch ashow}bind def
/H{0 rmoveto 0 exch 0 SC 5 2 roll awidthshow}bind def
/Q{moveto show}bind def
/S{moveto 0 exch ashow}bind def
/T{moveto 0 exch 0 SC 5 2 roll awidthshow}bind def
/Cg/setgray load def
/SN{
transform
.25 sub exch .25 sub exch
round .25 add exch round .25 add exch
itransform
}bind def
/LW/setlinewidth load def
/DL{
SN
moveto
SN
lineto stroke
}bind def
/SF{
findfont exch
[exch dup 0 exch 0 exch neg 0 0]makefont
dup setfont
[exch/setfont cvx]cvx bind def
}bind def
/BP{
1 setlinecap
1 setlinejoin
0 792 translate
1 -1 scale
}bind def
BP

/F0 10/Courier SF(Dice T)72 12 Q(ables)-.8 E(1d4;1d8)72 36 Q .4 LW
256 40.5 72 40.5 DL/F1 10/Courier SF 15(12345678)98 50 S 256 54.5 72
54.5 DL 256 56.5 72 56.5 DL 15(1QPZRY9X8)77 66 S 256 70.5 72 70.5 DL 15
(2GF2TVDW0)77 80 S 256 84.5 72 84.5 DL 15(3S3JN54KH)77 94 S 256 98.5 72
98.5 DL 15(4CE6MUA7L)77 108 S 256 112.5 72 112.5 DL 237.5 40.5 237.5
112.5 DL 216.5 40.5 216.5 112.5 DL 195.5 40.5 195.5 112.5 DL 174.5 40.5
174.5 112.5 DL 153.5 40.5 153.5 112.5 DL 132.5 40.5 132.5 112.5 DL 111.5
40.5 111.5 112.5 DL 89.5 40.5 89.5 112.5 DL 91.5 40.5 91.5 112.5 DL 256
40.5 256 112.5 DL 72 40.5 72 112.5 DL F0(2d6)72 132 Q 214 136.5 72 136.5
DL F1 15(123456)98 146 S 214 150.5 72 150.5 DL 214 152.5 72 152.5 DL 36
(1Q)77 162 S 15(PZR)-21 G 214 166.5 72 166.5 DL 15(2Y9X8GF)77 176 S 214
180.5 72 180.5 DL 15(32TVDW0)77 190 S 214 194.5 72 194.5 DL 15(4S3JN54)
77 204 S 214 208.5 72 208.5 DL 15(5KHCE6M)77 218 S 214 222.5 72 222.5 DL
36(6U)77 232 S 15(A7L)-21 G 214 236.5 72 236.5 DL 195.5 136.5 195.5
236.5 DL 174.5 136.5 174.5 236.5 DL 153.5 136.5 153.5 236.5 DL 132.5
136.5 132.5 236.5 DL 111.5 136.5 111.5 236.5 DL 89.5 136.5 89.5 236.5 DL
91.5 136.5 91.5 236.5 DL 214 136.5 214 236.5 DL 72 136.5 72 236.5 DL

0 Cg
end

pgsave restore
showpage
%%Page: 3 3
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
{ 10 dict begin
  /in exch def
  /out exch def
  16 out [ in out ] lagrange
  dup 1 eq {pop 0} if % X out trying to recover a share with itself.
  end
}
(Recover Share) /Symbol code2 /Courier code [ 32 permS 1 31 getinterval aload pop ] drawBottomWheelPage
pgsave restore
showpage
%%Page: 4 4
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
% note 0 and 1 are never used, so they are removed from the wheel.
gsave
pgsize aload pop 2 div exch 2 div exch translate
360 64 div rotate
16 {
  newpath 0 6 40 mul moveto 0 28 rlineto stroke
  360 16 div rotate
} repeat
grestore
{gf32mul} (Translation) /Courier code /Symbol code2 [32 1 1 31 {} for] drawBottomWheelPage

pgsave restore
showpage
%%Page: 5 5
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
{xor} (Addition) /Courier code 2 copy perm drawBottomWheelPage

pgsave restore
showpage
%%Page: 6 6
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
showTopWheelPage

pgsave restore
showpage
%%Page: 7 7
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
showTopWheelPage

pgsave restore
showpage
%%Page: 8 8
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
showTopWheelPage

pgsave restore
showpage
%%Page: 9 9
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
10 dict begin
    72 720 moveto
    /Helvetica findfont 20 scalefont setfont
    gsave (Constructing Shares) show grestore
    0 -20 rmoveto
    /Times-Roman findfont 12 scalefont setfont
    468 12
    [ [
    (Before constructing shares, you must choose your threshold value k, which is the number of)
    (shares needed to reconstruct the secret, and must be between 2 and 31 inclusive. \(k = 1 can be)
    (achieved by simply duplicating the original secret, and k > 31 is mathematically impossible with)
    (this scheme.\) Be aware that the work required during recovery is quadratic in k, so values greater)
    (than 4 are not recommended. You also cannot generate more than 31 shares total.)
    ] [
    (Next, generate the "S" share, which is the unshared secret, as well as k - 1 more shares with)
    (consecutive indices starting from "A". These initial shares should be generated randomly using)
    (dice, affixed with a header, then checksummed. See the Dice Table page and the Checksum)
    (Worksheet for more details.)
    ] [
    (For the case k = 2, you will have only two shares, S and A, and there is a simplified method)
    (available to generate the remaining shares. Use each character from your S share to select a table)
    (from the following pages. Look up the row indexed by the corresponding character of your A)
    (share, then read the corresponding character for the C share from the first column. The character)
    (for the D share will be in the column after that, and so on.)
    ] ] showParagraphs
    [
    (The general scheme is more involved:)
    (    1. Choose the appropriate table from this page based on your choice of k.)
    (    2. Find the column corresponding to the share you wish to create.)
    (    3. Translate each initial share by its symbol from that column, using the Translation Wheel.)
    (    4. Add all the translated initial shares together using the Addition Wheel.)
    ()
    (Tables for higher k can be easily generated by editing the source code of this file.)
    ]
    { gsave show grestore 0 -12 rmoveto } forall

    % EDITME
    % Edit these values to draw tables for larger k. Be warned that the total work to recover
    % a secret from k shares will be on the other of (48 + k - 1)k volvelle applications. For
    % k = 8 this is already over 250. And this is not even considering the logistics of keeping
    % eight distributed shares intact and available..
    /mink 2 def
    /maxk 6 def

    /x 104 def
    /y 400 def
    /rowtitle 6 string def
    mink 1 maxk {
        /k exch def

        0 1 k {
            /rowidx exch def
            x y moveto
            /Courier-Bold findfont 12 scalefont setfont
            rowidx 0 eq {
                % First row (heading)
                k (k =   ) rowtitle copy 4 2 getinterval cvs pop
                rowtitle show

                k mink sub { 12 0 rmoveto } repeat
                k 1 31 {
                    permS exch get code exch 1 getinterval gsave centreshow grestore
                    12 0 rmoveto
                } for % horizontal loop
            } {
                % Symbol rows
                /xinterp rowidx 1 sub def % x coord to interpolate at
                (      ) rowtitle copy 2 permS xinterp get code exch 1 getinterval putinterval
                rowtitle show

                /Symbol findfont 12 scalefont setfont
                k mink sub { 12 0 rmoveto } repeat
                k 1 31 {
                    permS exch get  % x coord to evaluate at
                    permS xinterp get % x coord to interpolate at
                    permS 0 k getinterval % x coords to interpolate at
                    lagrange % symbol
                    code2 exch 1 getinterval gsave centreshow grestore % print symbol
                    12 0 rmoveto
                } for % horizontal loop
            } ifelse


            /y y 11 sub def
        } for % vertical loop

        /y y 20 sub def
    } for

end

pgsave restore
showpage
%%Page: 10 10
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
29 24 13 25 showShareTablePage

pgsave restore
showpage
%%Page: 11 11
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
9 8 23 18 showShareTablePage

pgsave restore
showpage
%%Page: 12 12
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
22 31 27 19 showShareTablePage

pgsave restore
showpage
%%Page: 13 13
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
1 0 3 16 showShareTablePage

pgsave restore
showpage
%%Page: 14 14
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
11 28 12 14 showShareTablePage

pgsave restore
showpage
%%Page: 15 15
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
6 4 2 15 showShareTablePage

pgsave restore
showpage
%%Page: 16 16
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
10 17 21 20 showShareTablePage

pgsave restore
showpage
%%Page: 17 17
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
26 30 7 5 showShareTablePage

pgsave restore
showpage
%%Page: 18 18
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
   10 dict begin

   gsave
   /title (Multiplicaton) def
   /angle 360 31 div neg def
   % Move cursor to center of page
   pgsize aload pop 2 div exch 2 div exch translate
   % Draw white interior circle
   newpath 0 0 6 40 mul 29 sub 0 360 arc stroke
   newpath 0 0 6 40 mul 0 360 arc stroke
   newpath 0 0 6 0 360 arc stroke
   % Draw letters
   /Helvetica findfont 6 scalefont setfont
   gsave
   0 360 8 div 360 {title 6 3 -1 roll 234 outsidecircletext} for
   grestore
   /Symbol findfont 18 scalefont setfont
   permP 1 31 getinterval {0 38 sqrt 40 mul 29 sub moveto code2 exch 1 getinterval centreshow angle rotate} forall
   grestore

   end

pgsave restore
showpage
%%Page: 19 19
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
   10 dict begin

   gsave
   /title (Multiplicaton) def
   /angle 360 31 div neg def
   % Move cursor to center of page
   pgsize aload pop 2 div exch 2 div exch translate

   % Draw handle
   1 0 0 setrgbcolor
   newpath 6 40 mul 29 sub 7.25 40 mul moveto
   0 0 6 40 mul 29 sub 0 180 arc
   6 40 mul 29 sub neg 7.25 40 mul lineto
   closepath
   clip
   newpath 10 0 moveto
   30 0 lineto
   36 7.5 40 mul 29 sub 0 7.5 40 mul 29 sub 5 arct
   -36 7.5 40 mul 29 sub -30 0 5 arct
   -36 0 lineto
   -10 0 lineto
   -10 6 40 mul 8 sub lineto
   10 6 40 mul 8 sub lineto
   closepath
   0.8 setgray
   fill
   0 setgray
   initclip

   % Draw indicator arrow
   newpath 0 6 40 mul 8 sub moveto 8 16 rlineto -16 0 rlineto closepath fill

   % Draw white interior circle
   newpath 0 0 6 40 mul 29 sub 0 360 arc stroke
   % Draw centre cross
   newpath 0 6 moveto 0 -6 lineto stroke
   newpath 6 0 moveto -6 0 lineto stroke
   % Draw title
   /Helvetica findfont 12 scalefont setfont
   title 12 270 30 insidecircletext
   % Draw letters
   /Symbol findfont 18 scalefont setfont
   /sz 3 def
   permP 1 31 getinterval {
      0 24 sqrt 40 mul sz 2 mul sub moveto code2 exch 1 getinterval centreshow
      % Draw indicator arrow
      newpath 0 6 40 mul 29 sub moveto sz sz 2 mul neg rlineto sz 2 mul neg 0 rlineto closepath fill
      angle rotate
   } forall
   grestore

   end

pgsave restore
showpage
%%Page: 20 20
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
/Helvetica-Bold findfont 10 scalefont setfont
pgsize aload pop 40 sub exch 2 div exch
moveto (ms32 Checksum Table) centreshow

0 1 31 {
0 1 31 {
2 copy 730 exch 7 mul sub 1 index 11 idiv 240 mul sub exch 11 mod 50 mul 30 add exch moveto
2 copy
perm exch get exch perm exch get exch
2 copy
code exch get exch code exch get exch
2 string dup 1 4 3 roll put dup 0 4 3 roll put
/Courier-Bold findfont polymodulus length 6 le {8} {4.5} ifelse scalefont setfont
show
3 0 rmoveto
polymodulus length string
3 1 roll
polymodshift2 0 1 polymodulus length 1 sub { 3 copy get code exch get 3 2 roll exch put } for
pop
/Courier findfont polymodulus length 6 le {8} {4.5} ifelse scalefont setfont
show
pop
} for
pop
} for

pgsave restore
showpage
%%Page: 21 21
% %%PageOrientation: Landscape
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
%90 rotate 0 -750 translate

/hrp (bip39_24w) def
/thick 1 def
/thin 0.2 def
/box {
  10 dict begin
  { /width /beginred /n } {exch def} forall
  -1.2 -1.9 rmoveto
  0 14 rlineto
  arraySpace 0 rlineto
  0 -14 rlineto
  closepath
  width setlinewidth
  n beginred ge { gsave 1 0.9 0.9 setrgbcolor fill grestore } if
  stroke
  end
} bind def

/labeledbox {
  10 dict begin
  { /offset /beginred /n } {exch def} forall
  /n n hrp length add 2 add def
  gsave
    n beginred thick box
  grestore
  gsave
    arraySpace 6 sub 14 5 sub rmoveto
    /Courier findfont 3 scalefont setfont
    n offset add 10 lt { ( ) show } if n offset add 2 string cvs show
  grestore
  end
} bind def
/Helvetica-Bold findfont 10 scalefont setfont
pgsize aload pop pop 2 div 720
moveto (bip39_24w Checksum Worksheet) centreshow

/Courier findfont 15 scalefont setfont

186 680
% [10 29 19 13 4 16 20 8 16 7 4 13 6 8 27 31 28 14 17 21 31 25 19 15 1 3 13 29 22 5 8 31 9 17 15 30 19 15 21 16 19 26 16 22 31]
[ 62 {32} repeat ]
10 dict begin
{ /codeword /y /x } {exch def} forall
/odd polymodulus length codeword length add 2 mod def
x y moveto hrp (1) concatstrings dup stringwidth pop neg 3 sub odd 1 eq { arraySpace add } if 0 rmoveto show
/edge codeword length polymodulus length sub hrp length add 2 add def
/gaps [ 0 1 codeword length { 4 mod 1 eq {gapSpace} {arraySpace} ifelse } for ] def
/k polymodulus length odd sub def
  {edge 0 labeledbox} x arraySpace odd mul add y moveto codeword gaps 1 k getinterval 0 showArrayBox
/y y 14 sub def
/reduction [hrp polymodhrp aload pop k {0} repeat ] polymod0 def
  {reduction length thin box} x arraySpace odd mul add y moveto reduction gaps 1 k getinterval odd showArrayBox
  gsave
    /Helvetica findfont 9 scalefont setfont
    x y moveto
    odd 1 eq { arraySpace 0 rmoveto } if
    (+) dup stringwidth pop 2 add neg 2 rmoveto show
  grestore
/y y 15 sub def
/residue reduction [1 odd eq {0} if codeword 0 k getinterval aload pop ] gf32addarray def

{
  gsave
    /Helvetica findfont 9 scalefont setfont
    x y moveto (=) dup stringwidth pop 2 add neg 2 rmoveto show
  grestore
  k codeword length ge {exit} if
  { codeword length k sub 100 add thin box} x y moveto residue gaps k 1 add residue length sub residue length getinterval 0 showArrayBox
  {edge 100 add 0 labeledbox} codeword gaps k 1 add 2 getinterval k showArrayBox
  /x x gaps k 1 add reduction length sub 2 getinterval aload pop add add def
  /y y 14 sub def

  gsave
    /Helvetica findfont 9 scalefont setfont
    x y moveto (+) dup stringwidth pop 2 add neg 2 rmoveto show
  grestore

  /reduction residue 0 2 getinterval aload pop polymodshift2 def
  {reduction length thin box} x y moveto reduction gaps k 1 add reduction length 2 sub sub reduction length getinterval 0 showArrayBox
  /y y 15 sub def
  /residue reduction [residue 2 polymodulus length 2 sub getinterval aload pop codeword k 2 getinterval aload pop] gf32addarray def
  /k k 2 add def

  % mod 14: 4-split
  % mod 18: 3-split
  k 10 gt k 10 sub 18 mod 0 eq and {
      /x x 300 sub def
      /y y 70 add def
  } if
} loop

gsave 0.85 setgray x y moveto checksum gaps k 1 add residue length sub residue length getinterval 0 showArray grestore
{residue length thin box} x y moveto residue gaps k 1 add residue length sub residue length getinterval 0 showArrayBox

end

pgsave restore
showpage

%%Page: 22 22
%%BeginPageSetup
/pgsave save def
%%EndPageSetup

/Helvetica-bold findfont 10 scalefont setfont
pgsize aload pop pop 2 div 740
moveto (BIP-39 Conversion Worksheet) centreshow

% Draw boxes
/thin 0.2 def
/thick 0.4 def
/box {
  10 dict begin
  { /width } {exch def} forall
  -1.2 -1.9 rmoveto
  0 14 rlineto
  arraySpace 0 rlineto
  0 -14 rlineto
  closepath
  width setlinewidth
  stroke
  end
} bind def

/labeledbox {
  10 dict begin
  { /start /n } {exch def} forall
  /n n start add def
  gsave 0.5 box grestore
  % Every 5, write a top-left value
  gsave
    0 9 rmoveto
    /Courier findfont 3 scalefont setfont
    n 5 mod 0 eq {
         n 5 idiv 17 add 2 string cvs show
    } if
  grestore
  % Every 11 write a bottom-left value
  gsave
    0 14 rmoveto
    /Courier-Bold findfont 6 scalefont setfont
    n 11 mod 10 eq {
         n 11 idiv 1 add 2 string cvs show
    } if
  grestore
  end
} bind def

/showBox {
  10 dict begin
  { /n /spaces /decoration } {exch def} forall
  spaces { gsave n decoration grestore
      0 rmoveto
      /n n 1 add def
    } forall
  end
} bind def

% Draw 53 boxes in blocks of 5 bits
1 1 8 {
    /i exch def
    72 i 45 mul 740 sub neg moveto
    { i 1 sub 30 mul labeledbox} [ 6 {arraySpace arraySpace arraySpace arraySpace gapSpace} repeat ] 10 showBox % 30 bits
} for
9
72 exch 45 mul 740 sub neg moveto
{ 240 labeledbox} [ 5 {arraySpace arraySpace arraySpace arraySpace gapSpace} repeat ] 10 showBox % 30 bits

% Stick a 0 in there
395 336 moveto (0) show

% Write A-Z binary conversion table
/Courier findfont 12 scalefont setfont
0 setgray

/showbinary {
    16 dict begin
    /swap exch def
    /num exch def

    swap {
        code num 1 getinterval show
        ( : ) show
    } if

    /sc 1 def
    1 1 5 { pop /sc sc 2 mul def } for
    1 1 5 {
        /sc sc 2 idiv def
        num sc and 0 eq {(0)} {(1)} ifelse show
    } for

    swap not {
        ( : ) show
        code num 1 getinterval show
    } if
    end
} bind def

/showbinaries {
    16 dict begin
    /swap exch def
    /offset exch def
    /xstart exch def

    0 1 15 {
        dup
        14 mul 72 add xstart exch moveto

        offset exch sub
        swap {perm exch get} if swap showbinary
    } for

    end
} bind def

100 15 true showbinaries
180 31 true showbinaries

350 15 false showbinaries
430 31 false showbinaries


pgsave restore
showpage

%%Page: 23 23
%%PageOrientation: Landscape
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
90 rotate
1 1 8 {
    dup
    64 mul 1 sub exch
    92 mul 50 sub exch
    false showbinaries39
} for

pgsave restore
showpage

%%Page: 24 24
%%PageOrientation: Landscape
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
90 rotate
1 1 8 {
    dup
    64 mul 511 add exch
    92 mul 50 sub exch
    false showbinaries39
} for

pgsave restore
showpage

%%Page: 25 25
%%PageOrientation: Landscape
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
90 rotate
1 1 8 {
    dup
    64 mul 1023 add exch
    92 mul 50 sub exch
    false showbinaries39
} for

pgsave restore
showpage

%%Page: 26 26
%%PageOrientation: Landscape
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
90 rotate
1 1 8 {
    dup
    64 mul 1535 add exch
    92 mul 50 sub exch
    false showbinaries39
} for

pgsave restore
showpage

%%Page: 27 27
%%BeginPageSetup
/pgsave save def
%%EndPageSetup


% Can be done using
/Courier findfont 14 scalefont setfont
pgsize aload pop exch pop 5 div 700 moveto
%[ 0 30 10 20 23 3 18 1 0 66 {0} repeat ] polymod0 {
[ 0 0 0 0 0 0 0 1 0 66 {0} repeat ] polymod0 {
    code exch 1 getinterval show
} forall

% The remainder was an attempt to make a worksheet for this, but it is
% actually a bit complex because of the need to shift all the input chars
% by 66 places and then shift each remainder char by only 1 place
% Could be done in two passes but whatever
/thick 1 def
/thin 0.2 def
/box {
  10 dict begin
  { /width /n } {exch def} forall
  -1.2 -1.9 rmoveto
  0 14 rlineto
  arraySpace 0 rlineto
  0 -14 rlineto
  closepath
  width setlinewidth stroke
  end
} bind def

/labeledbox {
  10 dict begin
  { /offset /n } {exch def} forall
  gsave
    n thick box
  grestore
  gsave
    arraySpace 6 sub 14 5 sub rmoveto
    /Courier findfont 3 scalefont setfont
    n offset add 10 lt { ( ) show } if n offset add 2 string cvs show
  grestore
  end
} bind def

/chResidue {
    [ exch 66 {0} repeat ] polymod0
} bind def

36 480
%[ 0 30 10 20 23 3 18 1 0 ]
[ 0 0 0 0 0 0 0 1 0 ]

10 dict begin
{ /codeword /y /x } {exch def} forall

/k 0 def
/residue [
  codeword aload pop
  polymodulus length codeword length sub {0} repeat
] def
/gaps [ 0 1 codeword length polymodulus length add { 4 mod 1 eq {gapSpace} {arraySpace} ifelse } for ] def

codeword length {
  x y moveto
  { thin box }
    residue
    gaps k polymodulus length getinterval
    0 showArrayBox

%  { 0 labeledbox }
%    codeword
%    gaps k 1 getinterval
%    k showArrayBox

  /reduction residue 0 get chResidue def
  /x x k 4 mod 1 eq {gapSpace} {arraySpace} ifelse add def
  /y y 14 sub def
  /k k 1 add def

  x y moveto
  { thin box }
    reduction
    gaps k polymodulus length getinterval
    0 showArrayBox

  /y y 15 sub def
  /residue
    reduction
    [residue 1 polymodulus length 1 sub getinterval aload pop 0 ]
    gf32addarray def
} repeat

  x y moveto
  { thin box }
    residue
    gaps k polymodulus length getinterval
    0 showArrayBox


%gsave 0.85 setgray x y moveto checksum gaps k 1 add residue length sub residue length getinterval 0 showArray grestore
%{residue length thin box} x y moveto residue gaps k 1 add residue length sub residue length getinterval 0 showArrayBox

end


pgsave restore
showpage


%%EOF
