
%%Orientation: Portrait
%%Pages: 23
%%EndComments
%%BeginSetup
[(Shamir's Secret) (Sharing Codex)]
(revision alpha-4.6)
[
(MIT License)
()
(Copyright (c) 2020 Blockstream)
()
(Permission is hereby granted, free of charge, to any person obtaining a copy)
(of this software and associated documentation files (the "Software"), to deal)
(in the Software without restriction, including without limitation the rights)
(to use, copy, modify, merge, publish, distribute, sublicense, and/or sell)
(copies of the Software, and to permit persons to whom the Software is)
(furnished to do so, subject to the following conditions:)
()
(The above copyright notice and this permission notice shall be included in all)
(copies or substantial portions of the Software.)
()
(THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR)
(IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,)
(FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE)
(AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER)
(LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,)
(OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE)
(SOFTWARE.)
]
(WARNING:)
[
(Seriously, this is a work in progress, and it is only a concept right now.)
(If you try to use this for your valuable data, I promise you will lose your data.)
(You will lose this document and come back here only to find that I have made)
(incompatible changes, and your data is lost forever. Even if you don't lose)
(this document, there is no warranty or guarantee of any kind that you will be)
(able to recover successfully recover your data.)
]
%************************************************************************
%************************************************************************
%*
%* Section One: Preamble
%*
%************************************************************************
%************************************************************************

%******************
%* Front matter
%*
%* Define variables for the preceeding front matter text.
%*
/warning [ 4 2 roll exch [ exch ] exch ] def
/MIT exch def
/ver exch def
/title exch def

%******************
%* Main text content
%*
/allPageContent [
  [
    /section (Overview / Cheatsheet) /endsection
    /notoc % turn off table of contents indexing
    /dropcap (C) (ryptography is the art of hiding information. In particular, Shamir's)
    (Secret Sharing Scheme (SSSS) is used to hide secrets in a distributed way.)
    (A secret is split into multiple parts, called shares, that can be given)
    (to different people or kept in separate places. The)
    (shares can then be  used to reconstruct the original secret. For the)
    (wizards in the Bitcoin community, SSSS can be use to hide the single BIP32 master)
    (seed from which all their private keys are derived.)
    /paragraph
    (This codex describes a way for users, assisted by paper computers in the)
    (form of slide charts \(volvelles\) and circular slide rules, to perform)
    (checksums and SSSS on their Bitcoin secrets.)

    /subsection (Assembly) /endsubsection
    /bold (You will need:) /normal (craft knife, cardstock or heavy paper, brass fasteners, disc printouts.) /linebreak
    (Using the printouts from Module 0 \(which have pictographic instructions\),)
    /startlist
    /listitem1 (Cut out each disc with scissors. Cut out the windows on the top discs with the craft knife.) /endlistitem
    /listitem1 (Cut out the small centre circle in each bottom disc.)
      (Cut a slit along one one of the small lines of the cross in each top disc.) /endlistitem
    /listitem1 (Attach the discs with a brass fastener through the centre holes.) /endlistitem

    /subsection (Initial \(First k\) Share Creation) /endsubsection
    /bold (You will need:) /normal (Addition Volvelle, Dice Worksheet, Checksum Worksheet, pencil and eraser)
    /linebreak
    (For each of your initial k shares, you should)
    /startlist
    /listitem1 (Generate random data by rolling dice, following the instructions on the Dice Worksheet.) /endlistitem
    /listitem1 (Follow the instructions on the Checksum Worksheet to affix a checksum.) /endlistitem

    /subsection (Derived \(Remaining\) Share Creation) /endsubsection
    /bold (You will need:) /normal (Addition Volvelle, Multiplication/Translation Wheel, pencil)
    /startlist
    /listitem1 (Translate the initial shares using the symbols in the Derived Shares section) /endlistitem
    /listitem1 (Add the translated initial shares to get the new derived share.) /endlistitem

    /subsection (Secret Recovery) /endsubsection
    /bold (You will need:) /normal (Addition Volvelle, Multiplication/Translation Wheel, Recovery Wheel, pencil)
    (To recover your secret you must have k shares available. Then)
    /startlist
    /listitem1 (Look up their recovery symbols with the Recovery Wheel.) /endlistitem
    /listitem1 (Multiply all the symbols for each share with the Multiplication Wheel to get)
    (a single symbol for each share.) /endlistitem
    /listitem1 (Translate the share by that symbol.) /endlistitem
    /listitem1 (Add all the translated shares to get your secret.) /endlistitem
    /toc % turn off table of contents indexing
  ] [ % pagebreak
    /section (Part I: High-Level Introduction) /endsection
  ] [ % pagebreak
    /section (Part II: Detailed Instructions) /endsection
%    /dropcap (H) (ere we give a detailed overview of the share creation and recovery)
%    (process.)
%    /linebreak /linebreak % avoid bug between dropcap and subsequent heading
    /subsection (II.1. Tables and Volvelles) /endsubsection
    /dropcap (T) (hroughout the checksumming, share creation and recovery, there are four kinds)
    (of basic arithmetic that need to be done on bech32 characters and/or symbols.)
    (Since there are only 32 characters, each of these can be compactly represented)
    (by a lookup table.)
    /paragraph
    (However, the algebraic structure of this arithmetic lets us alternately represent)
    (these operations as) /bold (volvelles,) /normal (or paper computers. These are constructed from)
    (circular sheets of paper or cardstock, fastened through their centers such that)
    (they can rotate relative to each other.)
    /paragraph
    (We have one slide chart, which has windows in its top sheet which reveal symbols)
    (on the bottom; the rest of our volvelles are slide rules, which have all symbols)
    (visible on both top and bottom, and arrows mapping between them.)

    /subsection (II.2. Data Encoding) /endsubsection
    /dropcap (T) (o store 128-bit secrets, we round 128 up to 130, so that the secret can be)
    (represented by 26 bech32 characters. We prefix this with the 3 characters)
    /tt (ms1) /normal (and a 6-character header, and suffix it with a 13-character checksum:)

    /paragraph
    /paragraph
    /paragraph
    /paragraph
%| Human-readable Part | Threshold | Secret ID | Share Index | Secret data | Checksum |
%|---------------|--------|---------|--------|----------|----------|
%| 3 characters (`ms1`) | 1 character | 4 characters | 1 character | 26 characters | 13 characters |

    /paragraph
    /paragraph
    /paragraph
    /paragraph
    (The components of the header are:)
    /startlist
    /listitem* (The) /bold (threshold) /normal (indicates what the secret sharing)
     (threshold is, and should be a digit between) /tt (2) /normal (and) /tt (9) /normal
     (inclusive. Higher threshold values are not supported.) /endlistitem
    /listitem* (The) /bold (secret ID) /normal (is four arbitrary bech32 characters.)
     (They should be the same for all shares of a given secret, but distinct)
     (between secrets.) /endlistitem
    /listitem* (The) /bold (share index) /normal (indicates which share this is,)
     (and may be any bech32 character except) /tt (S.) /bold (The secret itself will)
     (have share index) /tt (S.) /normal /endlistitem

    /paragraph
    (If the user merely wants to checksum her secret, and not use secret splitting,)
    (she should use the same format, but with the digit) /tt (0) /normal (for the threshold value)
    (and) /tt (S) /normal (for the share index.)
  ] [ % pagebreak
    /subsection (II.3. Secret Splitting) /endsubsection
    /dropcap (S) (secret splitting is divided into two parts: generating the initial)
    (shares, which are random and independent from each other, and generating the)
    /bold (derived) /normal (shares, which are constructed from the initial ones.)

    /paragraph
    (If the user is not planning to use SSSS, and only wishes to checksum a single)
    (secret, she may also use these instructions, except that she should generate)
    (the single share) /tt (S) /normal (rather than k initial shares, and set the)
    (threshold value in the header to) /tt (0.)
    /normal

    /paragraph
    (In the case that the user has an existing secret in the form of BIP39 words,)
    (a similar but more complicated process is required, which is covered in Module 1.)
    (We do not discuss it here.)

    /subsubsection (II.3.a. Initial Share Generation) /endsubsubsection

    (To generate a split secret, the first step is to choose your threshold k. We)
    (require that it be between 2 and 9 inclusive, so that it can be represented by)
    (the bech32 characters) /tt (2) /normal (through) /tt (9.) /normal (Then take)
    (the k initial characters from the bech32 alphabet \() /tt (A, C, D,) /normal
    (and so on\), and create an initial share for each one:)
    /paragraph
    (Start by constructing the 6-chracter header, as described above, with the)
    (initial character as the share index. Then generate 26 random characters,)
    (as follows:)
    /startlist
    /listitem1 (Obtain five distinguishable dice. Label each of the five tracks)
      (on the following page with the name of each die.) /endlistitem
    /listitem1 (Roll all five dice, and set a marker on each track indicating)
      (the value on each die.) /endlistitem
    /listitem1 (Roll all five dice again, and set the die on the track according)
      (to its value.) /endlistitem
    /listitem1 (Redo both rolls for any dice that produced the same value twice.)
      /endlistitem
    /listitem1 (Follow the tree according to each track, moving left if the die)
      (is to the left of the marker, and moving right if the die is to the right)
      (of the marker.) /endlistitem
   % (insert page for dice tracks)
  ] [ % pagebreak
    /startText
    (Finally, generate a 13-character checksum on the header and random data, by)
    (following copying everything onto a fresh Checksum Worksheet and following.)
    (its instructions.)
    /paragraph
    (The checksum worksheet is likely to take 30-90 minutes, depending on user proficiency)
    (with the Addition volvelle. Even though this is a long time, we strongly recommend)
    (doing it twice, because mistakes made during checksum computation cannot be)
    (corrected after the fact.)

    /subsubsection (II.3.b. Derived Share Generation) /endsubsubsection
    (The k initial shares together actually form a set of k-of-k SSSS shares. However,)
    (the user likely would like a k-of-n scheme where n is bigger than k. In this case,)
    (the user needs to create (n-k) additional "derived" shares. These are not generated)
    (randomly but instead derived from the initial shares.)
    /paragraph
    (The steps are as follows:)
    /startlist
    /listitem1 (Choose the appropriate table from the next page based on your k value.)
      (For each of your initial shares, look up its translation symbol in that table.) /endlistitem
    /listitem1 (Translate the share, using the Translation volvelle with that symbol.) /endlistitem
    /listitem1 (Then add all the translated shares using the Addition volvelle.) /endlistitem
    15 { /paragraph } repeat % tables here
    (The result will be a new share, miraculously with a well-formed)
    (header and a valid checksum. To validate this checksum, fill out a fresh)
    (Checksum Worksheet with the new share.)
    /paragraph
    (You can easily generate tables for higher k by editing the source code of this document.)
  ] [ % pagebreak
    /startText
    (It is very likely that you will make mistakes during this process, resulting in a bad)
    (checksum. Mistakes during the translation step are correctable, but the error correction)
    (process involves computers and is not necessary here since the user has all the data)
    (she needs. Further, a bad checksum is just as likely to have resulted from incorrect)
    (computations in the Checksum Worksheet, which the error correction process cannot handle.)
    /paragraph
    (The most straightforward way to handle a wrong checksum is to redo the entire share)
    (derivation step, checking each calculation against the first time you did it.)
    /paragraph
    (There is a less demoralizing, but more time-consuming, way to do the share derivation)
    (process:)

    /startlist
    /listitem1 (Before beginning, make sure you have complete Checksum Worksheets for)
      (all of your initial shares \(if you just generated these, the worksheets should)
      (be readily available\).) /endlistitem
    /listitem1 (Copy your translated share into the bold boxes of a fresh Checksum Worksheet)
      (as usual.) /endlistitem
    /listitem1 (Repeat the translation-and-adding process, this time taking the) /bold
      (bottom diagonal squares) /normal (from the initial Checksum Worksheets and)
      (combining these. Copy the result into the bottom diagonal of the new)
      (Checksum Worksheet.) /endlistitem
    /listitem1 (Write the target residue) /tt (SECRETSHARE32) /normal (at the bottom)
      (of the Checksum Worksheet.) /endlistitem
    /paragraph
    (Then fill in the rest of the Checksum Worksheet as usual. If at any point)
    (you compute a value that doesn't match one of the pre-filled squares, redo)
    (the computations for) /bold (just that column.) /normal
    /subsubsection (II.3.c. Distribution) /endsubsubsection
    (Once the shares have been generated, there is no difference between the initial and)
    (derived shares. Distribute these as you wish.)
    /paragraph
    (You can generate up to 31 total shares before running out of available letters for)
    (share indices. You can make multiple copies of shares, but of course remember that)
    (only one copy counts during recovery: you need k *distinct* shares to recover your)
    (secret.)

  ] [ % pagebreak
    /subsection (II.4. Recovery) /endsubsection
    /dropcap (O) (nce you have generated and \(distributed\) your shares, you may like to)
    (recover your secret. In the future, we hope that hardware wallets will accept)
    (input of shares and do the recovery themselves, but we assume for this section)
    (that you want to recover your secret by hand.)
    /paragraph
    (First, make sure you have k shares available. Exactly k are needed; if you have)
    (more, then just set the extras aside.)
    /paragraph
    (The process is then very similar to the process for share derivation, except that)
    (rather than looking up symbols in a provided table, you use the Recovery Wheel)
    (volvelle to compute them as follows:)
    /startlist
    /listitem1 (Complete Checksum Worksheets for the k shares you are using. \(This)
      (is not strictly necessary, but if any mistakes happen during the recovery)
      (process it's helpful to be confident in your original shares' correctness.\))
      /endlistitem
    /listitem1 (For each share that you have,) /endlistitem
    /startsublist
    /sublistitem1 (Spin the Recovery slide chart so its pointer is at its share)
      (index. Read the symbol corresponding to) /bold (each other share.) /normal
      /endsublistitem
    /sublistitem1 (Multiply each of these symbols together using the Multiplication)
      (volvelle, by turning the pointer to one symbol, looking up the next, then)
      (spinning the wheel to the position you just looked up. \(For k = 2 you will)
      (have only one symbol, so this step is trivial: just spin the Multiplication)
      (slide chart to that symbol.\)) /endsublistitem
    /sublistitem1 (Leave the Multiplication volvelle pointed at the result of)
      (the previous step, and flip it over. It is now the Translation slide chart.)
      /endsublistitem
    /sublistitem1 (Translate the share, character by character.) /endsublistitem
    /listitem1 (Add the translated shares. The result will magically have a valid)
      (header and share index) /tt (S.) /normal (This is your secret. Keep it safe.)
      /endlistitem
    /listitem1 (Complete a Checksum Worksheet for the derived secret.) /endlistitem

    /paragraph
    (As during share derivation, if you use the checksum worksheets for your input shares,)
    (and repeat the translate-and-add process for the cells in the bottom diagonal, you)
    (can identify mistakes as soon as they happen, avoiding the need to repeat tons of)
    (work if you mess up.)

  ] [ % pagebreak
    /section (Volvelles) /endsection
  5 { ] [ } repeat % lol postscript
    /subsection (Checksum Table) /endsubsection
  ] [ % pagebreak
  ] [ % pagebreak
    /subsection (Checksum Worksheet) /endsubsection
  ] [ % pagebreak
    /subsection (Addition Worksheets) /endsubsection
  ]
] def

%******************
%* Helper Functions and Utilities
%*

% determinant : matrix -- det(matrix)
/determinant {
 1 0 2 index dtransform
 0 1 5 4 roll dtransform
 3 1 roll mul
 3 1 roll mul
 exch sub
} bind def

% tan : angle -- tan(angle)
/tan {
  dup sin exch cos div
} bind def

% arcsin: y h -- arcsin(y/h)
/arcsin {
   dup mul 1 index dup mul sub sqrt
   atan
} bind def

% Given a rod of length 2r, what angle does it fit inside a w by h sized box so that
% the ends of the rod are equaldistant from the two sides making a corner with the box.
/angleinbox {
10 dict begin
  { /r /h /w } {exch def} forall
  h w sub
  2 2 sqrt r mul mul
  arcsin 45 sub
end
} bind def

% Constructs a coordinate transformation used for the illustration of folding volvelles.
/foldprojection {
10 dict begin
  /foldangle exch def
  /squish 0.25 def
  /squash 1 squish dup mul sub sqrt def % sqrt (1 - squish^2)
  /rollangle squish neg 1 atan def
  [rollangle cos squish mul
   rollangle sin
   dup neg squish mul foldangle cos mul foldangle sin squash mul add
   rollangle cos foldangle cos mul
   0 0 ]
end

} bind def
/concatstrings % (a) (b) -> (ab)
   { exch dup length
     2 index length add string
     dup dup 4 2 roll copy length
     4 -1 roll putinterval
   } bind def

%******************
%* Field Arthmetic
%*
%* Calculations within GF(32), extended with the "null element", represented by
%* numberic 32, which is displayed as a blank, and on which every operation
%* returns null again. Used to represent incomplete/unknown data.
%*
%* Our generator for GF(32) has minimum polynomial x^5 + x^3 + 1.
%*
/gf32add % x y -> x [+] y where [+] is addition in GF32.
         % returns 32 if x or y is out of range.
         % Note that x [+] y = x [-] y in GF32.
{               % x y
 2 copy 32 ge   % x y x (y >= 32)
 exch 32 ge or  % x y (y >= 32 || x >= 32)
 {pop pop 32}     % 32
 {xor}            % x [+] y
 ifelse         % if (y >= 32 || x >= 32) then 32 else (x [+] y)
} bind def

/gf32mulalpha % x -> x [*] alpha where [*] is multiplicaiton in GF32 and alpha is represted by 0b00010.
{               % x
 2 mul          % 2*x
 dup 32 ge      % 2*x (2*x >= 0b100000)
 { 41 xor }       % 2*x `xor` 0b101001
 if             % if (2*x >= 0xb100000) then 2*x `xor` 0x0b101001 else 2*x
} bind def

/gf32mul % x y -> x [*] y where [*] is multiplication in GF32.
         % returns 32 if x or y is out of range.
{                % x y
 10 dict begin
 { /y /x } {exch def} forall
 x 32 ge y 32 ge or  % (y >= 32 || x >= 32)
 {32}                  % 32
 {
   /xShift x def
   /yAlpha y def
   0                   % 0
   5 {                                % ((x & 0b001..1) [*] y) (x >> i) (y [*] alpha[^i])
     xShift 1 and yAlpha mul xor      % ((x & 0b001..1) [*] y [+] ((x >> i) & 1) * (y [*] alpha [^i]))
     /xShift xShift -1 bitshift def
     /yAlpha yAlpha gf32mulalpha def
   } repeat            % ((x & 0b11111) [*] y)
 } ifelse            % if (y >= 32 || x >= 32) then 32 else (x [*] y)
 end
} bind def

/gf32inv % x -> x [^-1] where [^-1] is the inverse operation in GF32.
         % returns 0 when given 0.
         % returns 32 if x is out of range.
{                        % x
 dup dup gf32mul         % x x[^2]
 dup gf32mul gf32mul     % x[^5]
 dup dup gf32mul gf32mul % x[^15]
 dup gf32mul             % x[^30]
                         % x[^-1]
} bind def

/lagrange % x xj [x[0] .. x[k]] -> l[j](x)
          % returns the lagrange basis polynomial l[j] evaluated at x for interpolation of coordinates [x[0] .. x[k]].
          % Requires xj `elem` [x[0] ... x[k]]
{               % x xj [x[0] .. x[k]]
 10 dict begin
 { /xs /xj /x } {exch def} forall
 1 xs           % 1 [x[0] .. x[k]]
 {                % let P = product [(x [-] x[m]) [/] (xj [-] x[m]) | m <- [0..i-1], x[m] /= xj]
                  % P x[i]
   /xi exch def   % P
   xi xj gf32add  % P (xj [-] x[i])
   dup 0 eq       % P (xj [-] x[i]) (xj [-] x[i] == 0)
   { pop }                 % P
   { gf32inv gf32mul       % (P [/] (xj [-] x[i])
     xi x gf32add gf32mul  % (P [*] (x [-] x[i]) [/] (xj [-] x[i]))
   }
   ifelse         % (if xj == x[i] then P else (P [*] (x [-] x[i]) [/] (xj [-] x[i]))
 } forall       % x xj (product [(x [-] x[m]) [/] (xj [-] x[m]) | m <- [0..k], x[m] /= xj])
 end
} bind def

/makeShare % sS sA i -> si
       { 3 2 roll 1 index permS 0 get permS 0 2 getinterval lagrange gf32mul
         3 1 roll permS 1 get permS 0 2 getinterval lagrange gf32mul
         xor
       } bind def

/gf32mularray % x b -> x * b
  { [ 3 1 roll { 1 index gf32mul exch } forall pop ]
  } bind def

/gf32addarray % a b -> a + b pointwise
  { [ 3 1 roll 0 1 2 index length 1 sub { 2 index 1 index get 2 index 2 index get gf32add exch pop 3 1 roll } for pop pop ]
  } bind def

%******************
%* Code Parameters
%*
%* Data related to the representation of GF(32) elements
%*

/perm [29 24 13 25 9 8 23 18 22 31 27 19 1 0 3 16 11 28 12 14 6 4 2 15 10 17 21 20 26 30 7 5 ] def
/permS [16 29 24 13 25 9 8 23 18 22 31 27 19 1 0 3 11 28 12 14 6 4 2 15 10 17 21 20 26 30 7 5 ] def
/permV [22 11 10 29 31 28 17 24 27 12 21 13 19 14 20 25 1 6 26 9 0 4 30 8 3 2 7 23 16 15 5 18 ] def
/permId [ 0 1 31 {} for ] def

/code [/Q /P /Z /R /Y /nine /X /eight /G /F /two /T /V /D /W /zero /S /three /J /N /five /four /K /H /C /E /six /M /U /A /seven /L /space] def
/code2 [/multiply /aleph /alpha /beta /Gamma /Delta /epsilon /eta /Theta /Lambda /mu /Xi /Pi /rho /Sigma /Phi /Psi /Omega /at /numbersign /percent /cent /yen /Euro /currency /circleplus /dagger /daggerdbl /section /paragraph /diamond /heart /space ] def

%******************
%* BCH
%*
%* Data and functions related to the error-correcting code.
%*
/polymodulus [31 5 3 28 0 31 31 31 9 5 30 2 2] def % coefficents from c12 to c0
/checksum [16 25 24 3 25 11 16 23 29 3 25 17 10] def
/checksumstring { polymodulus length array checksum 0 1 polymodulus length 1 sub {3 copy exch 1 index get code exch 1 getinterval putinterval pop } for pop } bind def

/polymod0 % array -> [ c5 c4 c3 c2 c1 c0 ]
 { [ polymodulus length {0} repeat ]
   exch
   { [ exch 2 index 1 polymodulus length 1 sub getinterval aload pop polymodulus length dup 1 sub roll ] exch 0 get polymodulus gf32mularray gf32addarray  } forall
 } bind def

/polymodshift2 % c7 c6 -> [ c5 c4 c3 c2 c1 c0 ]
 {  [ 3 1 roll polymodulus length {0} repeat ] polymod0
 } bind def

/polymodhrp % string -> [ c5 c4 c3 c2 c1 c0 ]
 {
   [ exch 1 exch dup { 32 idiv exch } forall 0 exch { 31 and } forall ] polymod0
 } bind def

%************************************************************************
%************************************************************************
%*
%* Section Two: Graphics
%*
%************************************************************************
%************************************************************************

%******************
%* Helper Functions and Utilities
%*
/nullFont <<
  /face /Times-Roman
  /size 12
  /yDisp 0
  /rgbColor [ 0 0 0 ]
>> def

/textFont <<
  /face /Times-Roman
  /boldface /Times-Bold
  /ttface /Courier
  /size 12
  /footnotesize 10
  /yDisp 13
  /rgbColor [ 0 0 0 ]
>> def

/sectionFont <<
  /face /Times-Roman
  /size 32
  /yDisp 32
  /rgbColor [ 0.820 0.204 0.220 ]
>> def

/subSectionFont <<
  /face /Times-Roman
  /size 24
  /yDisp 20
  /rgbColor [ 0.820 0.204 0.220 ]
>> def

/subSubSectionFont <<
  /face /Times-Roman
  /size 18
  /yDisp 20
  /rgbColor [ 0.820 0.204 0.220 ]
>> def


/pgsize currentpagedevice /PageSize known
  { currentpagedevice /PageSize get
  } {
    [611.842163 791.842163] % letter size
  } ifelse
def

/marginpath {
10 dict begin
  pgsize aload pop
  /h exch def /w exch def
  /margin 18 def
  newpath
  margin margin moveto
  w margin sub margin lineto
  w margin sub h margin sub lineto
  margin h margin sub lineto
  closepath
end } bind def

% line : width --
/line {
  setlinewidth
  1 setlinecap
  1 setlinejoin
  [] 0 setdash
} bind def

/verythin 0.2 def
/thin 0.4 def
/thick 0.8 def
/verythick 1.2 def

% Runs stroke under a uniformly scaled matrix.
% ps2pdf doesn't seem to handle strokes under a non-uniformly scaled matrix properly.
/resetstroke {
matrix currentmatrix
  dup determinant abs
  initmatrix
  matrix currentmatrix determinant abs div
  sqrt dup scale
  stroke
setmatrix
} bind def

/brass { 0.7098 0.651 0.2588 } def

/substitute <<
  /Omega /uni03A9
  /circleplus /uni2295
>> def

% codexshow : /glyph size --
/codexshow {
10 dict begin
  /sz exch def
  /charname exch def
  /basefont /Courier findfont def
  /basechars basefont /CharStrings get def
  /backupfont /Symbol findfont def
  substitute charname known basechars charname known not and
    { basechars substitute charname get known { /charname substitute charname get def } if } if
  basechars charname known
  { basefont sz scalefont setfont charname glyphshow }
  { backupfont sz scalefont setfont charname glyphshow } ifelse
end
} bind def

/glyphwidth {
  gsave
  nulldevice newpath 0 0 moveto glyphshow currentpoint
  grestore
} bind def

/codexwidth {
  gsave
  nulldevice newpath 0 0 moveto codexshow currentpoint
  grestore
} bind def

/underlinecodexshow {
    exch
    dup dup /six eq exch /nine eq or { % if the string is (6) or (9)
        gsave /underscore 2 index codexshow grestore % draw an underline
    } if
    exch codexshow
} bind def

/centreshow {dup stringwidth pop 2 div neg 0 rmoveto show} bind def

/centrecodexshow {2 copy codexwidth pop 2 div neg 0 rmoveto underlinecodexshow} bind def

/centresquare {dup neg 2 div dup rmoveto dup 0 rlineto dup 0 exch rlineto neg 0 rlineto closepath stroke} bind def

% From BLUEBOOK Program #10
/outsidecircletext
  { circtextdict begin
      /radius exch def
      /centerangle exch def
      /ptsize exch def
      /str exch def
      /xradius radius ptsize 4 div add def

      gsave
        centerangle str findhalfangle add rotate

        str
          { /charcode exch def
            ( ) dup 0 charcode put outsideplacechar
          } forall
      grestore
    end
  } def

/insidecircletext
{ circtextdict begin
  /radius exch def /centerangle exch def
  /ptsize exch def /str exch def
  /xradius radius ptsize 3 div sub def
  gsave
   centerangle str findhalfangle sub rotate
   str
    { /charcode exch def
      ( ) dup 0 charcode put insideplacechar
    } forall
  grestore
  end
} def

/circtextdict 16 dict def
circtextdict begin
 /findhalfangle
  { stringwidth pop 2 div
    2 xradius mul pi mul div 360 mul
  } def

/outsideplacechar
    { /char exch def
      /halfangle char findhalfangle def
      gsave
        halfangle neg rotate
        radius 0 translate
        -90 rotate
        char stringwidth pop 2 div neg 0 moveto
        char show
      grestore
      halfangle 2 mul neg rotate
    } def

/insideplacechar
 { /char exch def
   /halfangle char findhalfangle def
   gsave
    halfangle rotate
    radius 0 translate
    90 rotate
    char stringwidth pop 2 div neg 0 moveto
    char show
   grestore
   halfangle 2 mul rotate
 } def

/pi 3.1415923 def
end

%******************
%* Content Rendering
%*
%* The bulk of the text is rendered using this streaming parser.
%*

% Shows a dropcap (giant letter with a bounding box around it)
%
% Takes coordinates to start drawing at, and the character to draw
% the bounding box in. Returns the height and width of the bounding
% box
/drawDropcap { % x y strdata -> h w
  10 dict begin
  gsave
    /Times-Roman findfont 64 scalefont setfont
    3 copy pop moveto

    gsave
      dup false charpath strokepath flattenpath pathbbox
      { /y2 /x2 /y1 /x1 } {exch def} forall
      % Flip box so it is going downward rather than upward
      /y2 y1 2 mul y2 sub store
    grestore

    % Draw letter
    0 y2 y1 sub rmoveto
    gsave
      dup true charpath
      x1 y2 moveto x1 y1 lineto x2 y1 lineto x2 y2 lineto closepath
      0.820 0.204 0.220 setrgbcolor
      % TODO Replace with a pattern fill.
      fill
    grestore
    dup false charpath
    x1 y2 moveto x1 y1 lineto x2 y1 lineto x2 y2 lineto closepath
    1 setlinewidth
    stroke

    % Return width and height
    pop pop
    x2 x1 sub
    y1 y2 sub
  grestore
  end
} bind def

% Displays a single word on the current device with the current font
% Returns the number of points before the end of the line, which will be
% negative in case of an overrun
/showWord { % word kernX maxX -> distance to maxX
  10 dict begin
  {/actuallyDraw /maxX /kernX /word} { exch def } forall

  <<
    /nametype {
      currentpoint {/y /x} { exch def } forall

      <<
        /footnotemark {
          /footnoteCount footnoteCount 1 add store
          % We need to idiv the footnote count by two since we double-increment
          % it accidentally (once when simulating and once when actually drawing)
          footnoteCount 2 idiv 2 string cvs
          gsave
            currentFont /face get findfont 6 scalefont setfont
            0 5 rmoveto
            actuallyDraw {
              show
            } {
              stringwidth pop 0 rmoveto
            } ifelse
          grestore
          % Adjust kerning because /footnotemark is a word
          kernX 0 rmoveto
          % Add an actual space though so the footnote isn't too crammed
          actuallyDraw { ( ) show } { ( ) stringwidth pop 0 rmoveto } ifelse
        }
        /bold {
          % add kerning because /bold is accounted for as a "word"
          % This causes distortion (extra spacing around bold text)
          % but empirically it seems pretty-much invisible
          kernX 0 rmoveto
          currentFont /boldface get findfont currentFont /size get scalefont setfont
        }
        /tt {
          % add kerning because /bold is accounted for as a "word"
          % This causes distortion (extra spacing around bold text)
          % but empirically it seems pretty-much invisible
          kernX 0 rmoveto
          currentFont /ttface get findfont currentFont /size get scalefont setfont
        }
        /normal {
          kernX 0 rmoveto
          currentFont /face get findfont currentFont /size get scalefont setfont
        }
      >> dup
      word known { word get exec } { pop } ifelse
      1 % arbitrary positive return value
    }
    /stringtype {
      % Prepend kerning (we expect the caller to set 0 kerning on the first word)
      kernX 0 rmoveto
      % Draw the actual word
      actuallyDraw {
        word show
        maxX currentpoint pop sub % compute return value prior to trailing space
      } {
        word stringwidth rmoveto
        maxX currentpoint pop sub % compute return value prior to trailing space
      } ifelse
      ( ) show % print a space so that copy/paste has a hope of working
    }
  >> begin word type exec end

  end
} bind def

% Takes as input a single page's contents and draws it
/drawPageContent { % x y [page content] -> nothing
  20 dict begin
  {/pagecontent /yorigin /xorigin} { exch def } forall

  xorigin yorigin moveto

  % state machine
  /buffer 200 string def
  <<
    % state
    /state /buffering
    /currentFont nullFont
    /x xorigin
    /y yorigin
    /dropcapWidth 0
    /dropcapHeight 0
    /maxX 540 % FIXME
    /wordBuffer 100 array
    /wordN 0
    /totalKern 0
    /footnoteCount 0
    /listItemCount 0
    /sublistItemCount 0

    /offsetX {
      x add /x exch store
      x y moveto
    }

    /offsetY {
      y dropcapHeight lt not % if we currently aren't past the dropcap...
      exch y add /y exch store
      y dropcapHeight lt and { % ...but after moving, we are...
        dropcapWidth neg offsetX % ...then shift x back to its original value
      } if
      x y moveto
    }

    /setCurrentFont {
      /currentFont exch store
      currentFont /face get findfont
      currentFont /size get scalefont
      setfont
      currentFont /rgbColor get aload pop setrgbcolor
    }

    % Output text, buffering mode (needed for fill justification)
    /buffering {
      /word exch def

      % Simulate writing the word, to see if it causes an overrun. If so...
      word 0 maxX false showWord dup 0 lt {
        % ...dump the previous line, with kerning
        totalKern wordN 1 gt { wordN 1 sub div } if dumpLastLine
        currentFont /yDisp get neg offsetY
        % ...then retry the word
        pop word buffering exec
      } {
        % ...otherwise, add word to buffer for next line's display
        /totalKern exch store
        wordBuffer wordN word put
        /wordN wordN 1 add store
      } ifelse
    }

    % Draw the contents of the current line buffer and flush it
    /dumpLastLine {
      x y moveto
      wordN 0 gt {
        wordBuffer 0 get 0 maxX true showWord pop
        wordBuffer 1 wordN 1 sub getinterval {
          1 index maxX true showWord pop
        } forall
      } if
      pop
      /wordN 0 store
    }

    /doLineBreak {
      0 dumpLastLine
      currentFont /yDisp get neg offsetY
    }

    % Output a dropcap
    /dropcapOneshot {
      % show dropcap, bumped up a bit
      x exch y 8 add exch drawDropcap
      % Store dropcap width and height of the bottom of the dropcap
      /dropcapHeight exch y sub neg store
      /dropcapWidth exch 4 add store
      % Move x and switch back to normal text mode
      dropcapWidth offsetX
      /state /buffering store
    }

    % content parsing
    /stringtype {
      { % loop through words in the string
        ( ) search {
          exch pop
          state load exec % Execute current state on word
        } {
          state load exec % Execute current state on last word
          exit
        } ifelse
      } loop
    }
    /nametype {
      <<
        /notoc {} % just eat table-of-contents token
        /toc {} % just eat table-of-contents token
        /dropcap { /state /dropcapOneshot store }
        /linebreak { doLineBreak }
        /paragraph { doLineBreak doLineBreak }
        /startlist { /listItemCount 0 store }
        /startsublist { /sublistItemCount 0 store }
        /listitem* {
          doLineBreak
          /y y 4 sub store
          /x x 24 add store
          x y moveto
          /bullet glyphwidth 8 add neg 0 rmoveto
          /bullet glyphshow
          x y moveto
        }
        /listitem1 {
          doLineBreak
          /listItemCount listItemCount 1 add store
          /y y 4 sub store
          /x x 24 add store
          x y moveto
          -5 0 rmoveto
          listItemCount 2 string cvs
          dup stringwidth pop neg 0 rmoveto show
          (.) show
          x y moveto
        }
        /sublistitem1 {
          doLineBreak
          /sublistItemCount sublistItemCount 1 add store
          /y y 4 sub store
          /x x 48 add store
          x y moveto
          -5 0 rmoveto
          sublistItemCount 2 string cvs
          dup stringwidth pop neg 0 rmoveto show
          (.) show
          x y moveto
        }
        /endsublistitem {
          0 dumpLastLine
          /x x 48 sub store
          x y moveto
        }
        /endlistitem {
          0 dumpLastLine
          /x x 24 sub store
          x y moveto
        }
        /startText {
          textFont setCurrentFont
          doLineBreak
        }
        /section {
          doLineBreak doLineBreak
          sectionFont setCurrentFont
          doLineBreak
        }
        /endsection {
          0 dumpLastLine
          % Draw underline
          currentpoint
          x y 4 sub moveto
          pop y 4 sub lineto 2 setlinewidth stroke

          doLineBreak
          textFont setCurrentFont
          /state /buffering store
        }
        /subsection {
          doLineBreak doLineBreak
          subSectionFont setCurrentFont
          doLineBreak
        }
        /endsubsection {
          0 dumpLastLine
          % Draw underline
          currentpoint
          x y 4 sub moveto
          pop y 4 sub lineto 1.5 setlinewidth stroke

          doLineBreak
          textFont setCurrentFont
          /state /buffering store
        }
        /subsubsection {
          doLineBreak doLineBreak
          subSubSectionFont setCurrentFont
          doLineBreak
        }
        /endsubsubsection {
          0 dumpLastLine
          % Draw underline
          currentpoint
          x y 4 sub moveto
          pop y 4 sub lineto 0.75 setlinewidth stroke

          doLineBreak
          textFont setCurrentFont
          /state /buffering store
        }
        /footnotes {
          0 dumpLastLine

          /footnoteCount 0 store
          /y y 12 sub store
          x y moveto x 100 add y lineto 0.5 setlinewidth stroke
          /y y 12 sub store
          x y moveto
          currentFont /face get findfont currentFont /footnotesize get scalefont setfont
        }
      >> exch 2 copy
      known {
        get exec
      } {
        % just pass unknown symbols to buffering so that they will wind up
        % in the line buffer, and take effect both during the simulated
        % (spacing-computing) layout and the real layout
        buffering pop
      } ifelse
    }
  >> begin
    pagecontent { dup type exec } forall
    0 dumpLastLine
  end

  end
} bind def

%******************
%* Volvelle and Slide Charts
%*
/magic 94 def % a magic angle for making nice looking spirals.
/drawBottomWheelPage
 { 10 dict begin
   /outerperm exch def
   /outercode exch def
   /innercode exch def
   /title exch def
   /binop exch def
   /angle 360 outerperm length div neg def
   % Move cursor to center of page
   pgsize aload pop 2 div exch 2 div exch translate
   % Draw white interior circle
   newpath 0 0 6 40 mul 0 360 arc stroke
   gsave verythin line
     newpath 0 0 6 40 mul 28 add 0 360 arc stroke
     newpath 0 0 6 0 360 arc stroke
   grestore
   % Draw title (small text, repeated)
   /Helvetica findfont 12 scalefont setfont
   title 12 270 30 insidecircletext
   % Draw letters (using human-centric ABCD... permutation)
   /Helvetica findfont 6 scalefont setfont
   gsave
   360 16 div 360 64 div sub rotate
   0 360 8 div 360 {title 6 3 -1 roll 262 outsidecircletext} for
   grestore
   outerperm {0 38 sqrt 40 mul moveto outercode exch get 18 centrecodexshow angle rotate} forall
   % Draw inside contents
   180 rotate
   0 1 31 { % Draw 32 circles of increasing radius
       magic rotate
       outerperm {
           0 2 index 2 add sqrt 40 mul moveto % move to 0, 2.5 + 40*sqrt(outer index + 2)
           1 index 31 exch sub % 31 - inner index
           permV exch get binop % apply binary operation to the permuted letter and the inner index
           innercode exch get 12 centrecodexshow % display the result
           angle rotate % rotate one entry
       } forall pop
   } for
   end
 } bind def

/showTopWheelPage
 {
   % Move cursor to center of page
   pgsize aload pop 2 div exch 2 div exch translate
   gsave verythin line
     newpath 0 0 6 40 mul 0 360 arc stroke
   grestore
   % Draw gray "handle" and white interior circle
   gsave
     0.8 setgray
     newpath 0 0 7.25 40 mul 140 40 arc clip fill
     1 setgray
     newpath 0 0 6 40 mul 0 360 arc fill
     0 setgray
     newpath 0 0 6 40 mul 0 360 arc stroke
   grestore
   % Draw centre cross
   gsave verythin line
     newpath 0 6 moveto 0 -6 lineto stroke
     newpath 6 0 moveto -6 0 lineto stroke
   grestore
   % Draw indicator arrow
   newpath 0 6 40 mul moveto 10 -20 rlineto -20 0 rlineto closepath fill
   % Draw text
   180 rotate
   0 1 31 {
       magic rotate
       dup 2 add sqrt 40 mul 2.5 add % lam = 2.5 + 40*sqrt(idx + 2)
       newpath
       0 exch % set midpoint: 0 lam
       2 copy moveto
       12 centresquare % draw square
       moveto % return to midpoint
       -26 -3 rmoveto % Move to the left
       31 exch sub % 31 - loop index
       permV exch get code exch get % Permute index and extract 1-char substring of alphabet
       12 underlinecodexshow % ...and draw it
       /Symbol findfont 12 scalefont setfont /arrowright glyphshow % Draw a right arrow
   } for
 } bind def

% drawPointer : sz --
% draws a fillied triangle of sz pointing up (or down if sz is negative).
/drawPointer {
  /sz exch def
  0 sz eq not {
    sz 2 div sz neg rlineto sz neg 0 rlineto closepath fill
  } if
} bind def

% drawPin : sz --
% draws a sylized brass fasstener
/drawPin {
gsave
  /sz exch def
  currentpoint newpath moveto
  sz -2 div sz 3.5 mul rmoveto
  sz 0 rlineto
  sz 0 sz sz sz -2 div sz rcurveto
  sz -1.5 mul 0 sz -1.5 mul sz neg sz -2 div sz neg rcurveto
  0 sz -3 mul rlineto
  sz 2 div dup neg rlineto
  sz 2 div dup rlineto
  0 sz 3 mul rlineto
  closepath
  gsave brass setrgbcolor fill grestore
  thin line stroke
grestore
} bind def
% drawSplitPin : sz --
% draws a sylaized open brass fastener.
/drawSplitPin {
  /sz exch def
  currentpoint
  newpath moveto
  0 sz -3.5 mul rmoveto
  sz -2 div sz 3.5 mul rmoveto
  0 sz -3 mul rlineto
  sz 2 div dup neg rlineto
  sz 2 div dup rlineto
  0 sz 3 mul rlineto
  closepath
  sz 2 div sz 3.5 mul rmoveto
  sz 2 div sz -3.5 mul rmoveto
  0 sz 3 mul rlineto
  sz -2 div dup neg rlineto
  sz -2 div dup rlineto
  0 sz -3 mul rlineto
  closepath
  gsave brass setrgbcolor fill grestore
  gsave thin line stroke grestore
} bind def

% arrowHeadPath : x y r angle sz --
% creates an arrow head path for the end of a arc
/arrowHeadPath {
10 dict begin
  { /sz /angle /r /y /x } {exch def} forall
  matrix currentmatrix
    x y translate
    angle rotate
    r sz add sz neg moveto
    r 0 lineto
    sz neg dup rlineto
  setmatrix
end
} bind def

30 dict dup /multiplicationDisc exch def begin
  /radius 200 def
  /title (Multiplication) def
  /outerTitleSz 6 def
  /outerglyphSz 18 def
  /outerPointerSz 0 def
  /innerRadius { radius outerTitleSz outerglyphSz add sub outerPointerSz add } bind def
  /innerglyphSz { outerglyphSz } def
  /innerTitleSz 12 def
  /innerPointerSz 6 def
  /handlePointerSz -16 def
  % the fold line for the bottom disc is slightly less that the disc radius.
  /bottomfoldline { radius angle 2 div cos mul } bind def
  /topfoldline { radius 27 add } bind def
  /handlewidth 54 def

  /logbase 19 def
  /coding code2 def
  /numglyphs 31 def
  /angle 360 numglyphs div def
  /outerglyphs { [ [ 1 numglyphs 1 sub {dup logbase gf32inv gf32mul} repeat ] {coding exch get} forall ] } bind def
  /innerglyphs { outerglyphs } def

  /outlineBottomDisc {
      radius 0 moveto
      0 0 radius 0 360 arc
      4.5 0 moveto
      0 0 4.5 360 0 arcn
  } bind def

  /drawBottomDisc {
     % Draw white interior circle
     newpath
     outlineBottomDisc
     verythin line resetstroke
     newpath 0 0 innerRadius 0 360 arc thick line resetstroke
     % Draw letters
     gsave
       /Helvetica findfont outerTitleSz scalefont setfont
       360 8 div dup 2 div exch 360 {title outerTitleSz 3 -1 roll radius outerTitleSz sub outsidecircletext} for
     grestore
     outerglyphs {
       0 radius outerTitleSz outerglyphSz 0.8 mul add sub moveto outerglyphSz centrecodexshow
       % Draw indicator pointer
       0 innerRadius moveto outerPointerSz drawPointer
       angle rotate
     } forall
  } bind def

  /handleCapPath {
      handlewidth 2 div topfoldline 5 sub moveto
      handlewidth 2 div topfoldline handlewidth -2 div topfoldline 5 arct
      handlewidth -2 div topfoldline 2 copy 5 sub 5 arct
  } bind def
  /outlineTopDisc {
      handleCapPath
      0 0 innerRadius handlewidth 2 innerRadius mul arcsin dup 90 add exch 450 exch sub arc
      closepath
      /charwidth /space innerglyphSz codexwidth pop 1.2 mul def
      charwidth 2 div innerRadius outerPointerSz sub moveto
      charwidth 2 div neg innerRadius outerPointerSz sub lineto
      charwidth 2 div neg radius outerTitleSz sub lineto
      charwidth 2 div radius outerTitleSz sub lineto
      closepath
  } bind def

  /drawTopDisc {
     gsave decorateTopDisc grestore

     /charwidth /space innerglyphSz codexwidth pop 1.2 mul def

     % Draw handle
     gsave
       newpath innerRadius topfoldline moveto
       0 0 innerRadius 0 180 arc
       innerRadius neg topfoldline lineto
       closepath
       clip
       newpath
       handleCapPath
       handlewidth -2 div 0 lineto
       handlewidth 2 div 0 lineto
       closepath
       charwidth 2 div innerRadius outerPointerSz sub moveto
       charwidth 2 div neg innerRadius outerPointerSz sub lineto
       charwidth 2 div neg radius outerTitleSz sub lineto
       charwidth 2 div radius outerTitleSz sub lineto
       closepath
       0.8 setgray
       fill
     grestore

     % Draw indicator pointer
     0 radius outerTitleSz sub moveto handlePointerSz drawPointer

     gsave verythin line
       % Draw white interior circle
       newpath 0 0 innerRadius 0 360 arc resetstroke
       % Draw centre cross
       newpath 0 4.5 moveto 0 -4.5 lineto 4.5 0 moveto -4.5 0 lineto resetstroke
     grestore
     % Draw title
     gsave
       /Helvetica findfont innerTitleSz scalefont setfont
       title innerTitleSz 270 30 insidecircletext
     grestore
     % Draw letters
     innerglyphs {
        0 innerRadius innerglyphSz 0.8 mul sub innerPointerSz sub moveto innerglyphSz centrecodexshow
        % Draw indicator pointer
        0 innerRadius moveto innerPointerSz drawPointer
        angle rotate
     } forall
  } bind def
  /decorateTopDisc {} def
end

% /translationDisc is a modified copy of multiplicaitonDisc.
multiplicationDisc dup maxlength dict copy dup /translationDisc exch def begin
  /title (Translation) def
  /logbase 23 def
  /coding code def
  /handlePointerSz 0 def
  /decorateTopDisc {
    [/Q /arrowboth /Q]
    dup 0 exch {outerglyphSz 2 mul codexwidth pop add} forall -2 div outerglyphSz 2 mul moveto
    {outerglyphSz 2 mul codexshow} forall
  } bind def
end

% /recoveryDisc is a modified copy of multiplicaitonDisc.
multiplicationDisc dup maxlength dict copy dup /recoveryDisc exch def begin
  /title (Recovery) def
  /logbase 10 def
  /outerglyphs {
     [ [ 1 numglyphs 1 sub {dup logbase gf32inv gf32mul} repeat ]
       {16 xor code exch get} forall ]
  } bind def
  /outerPointerSz -6 def
  /innerglyphs {
     [ [ 1 numglyphs 1 sub {dup logbase gf32inv gf32mul} repeat ]
       { 16 xor [ exch 17 ] 16 17 3 -1 roll lagrange
         dup 1 eq {pop 32} if
         code2 exch get
       } forall ]
  } bind def
  /innerPointerSz 0 def
  /decorateTopDisc {
     /littleR 1 def
     /bigR innerRadius innerPointerSz sub innerglyphSz sub littleR sub def
     thin line
     0.8 setgray
     1 1 numglyphs 2 idiv {
       angle mul dup sin bigR mul exch cos bigR mul
       newpath 2 copy littleR -180 180 arc
       exch neg exch littleR 0 360 arc
       resetstroke
     } for
  } bind def
end

% foldingBottomDiscs: angle1 angle2 --
% Renders an illustration of a folded multiplication and translation bottom disc pair.
/foldingBottomDiscs {
10 dict begin
  { /angle2 /angle1 } {exch def} forall

  matrix currentmatrix
  dup determinant /det exch def
    angle2 foldprojection concat
    translationDisc begin
      0 bottomfoldline translate
      180 rotate
      radius neg dup radius 2 mul radius bottomfoldline add rectclip
      gsave newpath outlineBottomDisc 1 setgray fill grestore
      matrix currentmatrix determinant det mul 0 gt
      { drawBottomDisc }
      { newpath outlineBottomDisc verythin line resetstroke }
      ifelse
      initclip
    end
  dup setmatrix
    angle1 foldprojection concat
    multiplicationDisc begin
      0 bottomfoldline neg translate
      radius neg dup radius 2 mul radius bottomfoldline add rectclip
      gsave newpath outlineBottomDisc 1 setgray fill grestore
      drawBottomDisc
      % draw fold line
      initclip
      0 0 radius 0 360 arc clip
      newpath radius bottomfoldline moveto radius -2 mul 0 rlineto verythin line resetstroke
      initclip
    end
  setmatrix
end
} bind def

%******************
%* Checksum Worksheet
%*
%* Functionality for the checksum, addition, bit conversion, etc., worksheets,
%* to assist user manipulation of long bech32 strings
%*

/arraySpace 13 def
/gapSpace arraySpace 2 add def
/showArray {
  10 dict begin
  { /n /spaces /word } {exch def} forall
  0 1 spaces length 1 sub
    { code word n get get gsave 15 codexshow grestore
      spaces exch get 0 rmoveto
      /n n 1 add def
    } for
  end
} bind def

/showBox {
  10 dict begin
  { /n /spaces /word /decoration } {exch def} forall
  spaces { gsave n decoration grestore
      0 rmoveto
      /n n 1 add def
    } forall
  end
} bind def

/showArrayBox {
  4 copy gsave showBox grestore
  showArray pop
} bind def

/showParagraphs {
  10 dict begin
  { /paragraphs /height /width } {exch def} forall
  paragraphs {
    /lines exch def
    lines 0 lines length 1 sub getinterval {
      /line exch def
      % Compute amount of space needed for each /space character
      width line stringwidth pop sub 0 line { 32 eq { 1 add } if} forall div
      0 32 line gsave widthshow grestore
      0 height neg rmoveto
    } forall
    lines lines length 1 sub get gsave show grestore
    0 height neg 2 mul rmoveto
  } forall
  end
} bind def

/box {
  10 dict begin
  { /width /beginred /n } {exch def} forall
  -1.2 -1.9 rmoveto
  0 14 rlineto
  arraySpace 0 rlineto
  0 -14 rlineto
  closepath
  width setlinewidth
  n beginred ge { gsave 1 0.9 0.9 setrgbcolor fill grestore } if
  stroke
  end
} bind def

%******************
%* Tables and Diagrams
%*
%* Tables, diagrams etc provided throughout the text which may be repeated

/drawDataFormat {
  10 dict begin
  {/y /x} {exch def} forall
  /boxW pgsize aload pop pop 144 sub 35 div def

  x y moveto
  % FIXME use russell's line font
  /Courier findfont 14 scalefont setfont
  % Draw left 13 boxes
  1 1 13 {
    pop
    gsave
      [] 0 setdash
      boxW 0 rlineto
      0 -14 rlineto
      boxW neg 0 rlineto
      closepath stroke
    grestore
    boxW 0 rmoveto
  } for
  % Draw dashed line
  boxW 2 div 0 rmoveto
  0 -7 rmoveto
  [1 2] 0 setdash
  boxW 4 mul 0
  gsave 2 copy rlineto stroke grestore
  rmoveto
  0 7 rmoveto
  boxW 2 div 0 rmoveto
  % Draw right 17 boxes
  1 1 17 {
    pop
    gsave
      [] 0 setdash
      boxW 0 rlineto
      0 -14 rlineto
      boxW neg 0 rlineto
      closepath stroke
    grestore
    boxW 0 rmoveto
  } for

  % Draw a brace, moving the current point to the right
  % by width many pts
  /drawBrace { % width height -> nil
    10 dict begin
    {/height /width} {exch def} forall
    gsave
      -2 height 2 div rmoveto
      [] 0 setdash
      height abs height rlineto
      width 4 add 2 height mul abs sub 0 rlineto
      height abs height neg rlineto
      stroke
    grestore
    width 0 rmoveto
    end
  } bind def

  x y moveto
  /braceH -3 def
  3 boxW mul 0 rmoveto
  [ 1 4 1 13 13 ] {
    0 5 braceH mul rmoveto
    boxW exch mul braceH drawBrace
    /braceH braceH neg store
  } forall

  % Draw example characters in boxes
  x y moveto
  2 -12 rmoveto % manually center characters in box
  /sampleString (ms13SSSSA79NT     9Y6AHQ829ZQZVEGNF) def
  0 1 sampleString length 1 sub {
    sampleString exch 1 getinterval gsave show grestore
    boxW 0 rmoveto
  } for

  % Draw headings above/below braces
  /Helvetica findfont 12 scalefont setfont
  x y moveto
  3.5 boxW mul -32 rmoveto
  gsave
    gsave (recovery) centreshow grestore
    0 -12 rmoveto gsave (threshold) centreshow grestore
    0 -12 rmoveto gsave (\(k\)) centreshow grestore
  grestore

  2.5 boxW mul 40 rmoveto
  gsave
    gsave (ID) centreshow grestore
  grestore

  2.5 boxW mul -40 rmoveto
  gsave
    gsave (share) centreshow grestore
    0 -12 rmoveto gsave (index) centreshow grestore
  grestore

  6.5 boxW mul 40 rmoveto
  gsave (data \(26 chars for 128 bits\)) centreshow grestore

  13 boxW mul -40 rmoveto
  gsave (checksum \(13 chars\)) centreshow grestore

  end
} bind def
%%EndSetup

%************************************************************************
%************************************************************************
%*
%* Section Three: Page Rendering
%*
%************************************************************************
%************************************************************************

%****************************************************************
%*
%* Title Page
%*
%****************************************************************
%%Page: (i) 1
%%BeginPageSetup
/pgsave save def
%%EndPageSetup

/Times-Roman findfont 48 scalefont setfont
pgsize aload pop exch 2 div exch 300 sub moveto
title {gsave centreshow grestore 0 -70 rmoveto} forall

/Times-Roman findfont 16 scalefont setfont
pgsize aload pop exch 2 div exch 700 sub moveto ver centreshow

pgsave restore
showpage

%****************************************************************
%*
%* License Information
%*
%****************************************************************
%%Page: (ii) 2
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
/Courier findfont 10 scalefont setfont
40 750 moveto
MIT {gsave ((c)) search {show pop /copyright glyphshow} if show grestore 0 -12 rmoveto} forall
/Helvetica findfont 14 scalefont setfont
0 -16 rmoveto
468 14 warning showParagraphs
pgsave restore
showpage

%****************************************************************
%*
%* Arithmetic Tables
%*
%****************************************************************
%%Page: (iii) 3
%%BeginPageSetup
/pgsave save def
%%EndPageSetup

/Helvetica-Bold findfont 16 scalefont setfont
pgsize aload pop 48 sub exch 2 div exch
moveto (Principal Tables) centreshow

pgsize aload pop
/tHeight exch 108 sub 2 div def
/tWidth exch 72 sub 2 div def

/drawTable {
  10 dict begin
  { /innerCode /topPerm /topCode /leftPerm /leftCode /title /binop /y /x } {exch def} forall

  % Top 16 pts are title
  x y moveto
  /Helvetica findfont 12 scalefont setfont
  tWidth 2 div -12 rmoveto title centreshow

  % Remainder is split into the table (one extra row and column for heading)
  /cellH tHeight 16 sub leftPerm length 1 add div def
  /cellW tWidth topPerm length 1 add div def

  % Draw vertical background lines: one black one for the heading then
  % alternating 3-cell-height white/gray for the content background
  x y 16 sub moveto
  0 1 topPerm length {
    dup 0 eq { 0 0 0 } {
      3 add 6 mod 3 lt { 0.808 0.923 0.953 } { 1 1 1 } ifelse
    } ifelse setrgbcolor

    gsave
      0 tHeight 16 sub neg rlineto
      cellW 0 rlineto 0 tHeight 16 sub rlineto closepath fill
    grestore
    cellW 0 rmoveto
  } for
  % Draw horizontal background line for top heading
  0 setgray
  x y 16 sub moveto
  x tWidth add y 16 sub lineto
  0 cellH neg rlineto
  x y 16 cellH add sub lineto
  closepath fill
  % Draw vertical lines
  0.1 setlinewidth
  % Draw horizontal lines
  x y 16 sub moveto
  0 1 leftPerm length {
    0 cellH neg rmoveto
    3 mod 2 eq {
      gsave tWidth 0 rlineto stroke grestore
    } if
  } for

  1 setgray
  % Draw top title
  x cellW 2 div add y 16 sub cellH sub 2 add moveto
  0 1 topPerm length 1 sub {
    cellW 0 rmoveto
    topPerm exch get topCode exch get gsave 10 centrecodexshow grestore
  } for
  % Draw left title
  x cellW 2 div add y 16 sub cellH sub 2 add moveto
  0 1 leftPerm length 1 sub {
    0 cellH neg rmoveto
    leftPerm exch get leftCode exch get gsave 10 centrecodexshow grestore
  } for

  0 setgray
  % Draw content
  x cellW 2 div add y 16 sub cellH sub 2 add moveto
  0 1 topPerm length 1 sub { % x
    cellW 0 rmoveto
    gsave
    0 1 leftPerm length 1 sub { % y
      0 cellH neg rmoveto
      1 index
      /xpos exch topPerm exch get def
      /ypos exch leftPerm exch get def
      innerCode xpos ypos binop get
      gsave 10 centrecodexshow grestore
    } for
    pop
    grestore
  } for

  % Bounding box
  0.5 setlinewidth
  x y 16 sub moveto
  0 tHeight 16 sub neg rlineto
  tWidth 0 rlineto
  0 tHeight 16 sub rlineto
  closepath stroke

  end
} bind def

% top-left
28 tHeight tHeight 56 add add
{gf32add} (Addition) code perm code perm code drawTable
% top-right
tWidth 44 add tHeight tHeight 56 add add
{gf32mul} (Translation) code perm code2 permId 1 31 getinterval code drawTable
% bot-left
28 tHeight 48 add
{ 10 dict begin
  /in exch def
  /out exch def
  16 out [ in out ] lagrange
  dup 1 eq {pop 0} if % X out trying to recover a share with itself.
  end
}
(Recovery) code permS 1 31 getinterval code permS 1 31 getinterval code2 drawTable
% bot-right
tWidth 44 add tHeight 48 add
{gf32mul} (Multiplication) code2 permId 1 31 getinterval code2 permId 1 31 getinterval code2 drawTable

pgsave restore
showpage

%****************************************************************
%*
%* Reference Page
%*
%****************************************************************
%%Page: (iv) 4
%%BeginPageSetup
/pgsave save def
%%EndPageSetup

% Takes a position specified as percentages of page width/height (excluding
% margins) and computes the actual x/y coordinates in pts
/position { % x y -> x y
  10 dict begin
    /y exch def
    /x exch def
    pgsize aload pop
    /pageH exch def
    /pageW exch def
    pageW 144 sub x mul 72 add
    pageH 144 sub y mul 72 add
    neg pageH add % invert y so that "0" is at the top of the page
  end
} bind def

%
% Header/data format
%

/Helvetica-Bold findfont 16 scalefont setfont
0.5 0 position moveto (Data Format) centreshow

0 0.05 position drawDataFormat

%
% bech32->binary chart
%
0.50 0.20 position moveto
/Helvetica-Bold findfont 16 scalefont setfont
(Bech32 to Binary Conversion) centreshow
/Courier findfont 12 scalefont setfont

0.5 0.23 position moveto
22 string stringwidth pop neg 0 rmoveto % goofy centering logic
0 8 {
  gsave 4 {
    dup
    perm exch get
    code 1 index get glyphshow (: ) show
    32 5 { 2 idiv 2 copy and 0 eq {(0)} {(1)} ifelse show } repeat pop
    pop
    (    ) show 1 add
  } repeat grestore
  0 -14 rmoveto
} repeat pop

0.50 0.45 position moveto
/Helvetica-Bold findfont 16 scalefont setfont
(Binary to Bech32 Conversion) centreshow
/Courier findfont 12 scalefont setfont

0.5 0.48 position moveto
22 string stringwidth pop neg 0 rmoveto % goofy centering logic
0 8 {
  gsave 4 {
    dup
    32 5 { 2 idiv 2 copy and 0 eq {(0)} {(1)} ifelse show } repeat pop
    (: ) show code 1 index get glyphshow
    pop
    (    ) show 1 add
  } repeat grestore
  0 -14 rmoveto
} repeat pop

%
% Symbol pronunciation
%
/Helvetica-Bold findfont 16 scalefont setfont
0.5 0.72 position moveto
(Symbols) centreshow

/pronunciation <<
  /multiply (cross)   /aleph  (aleph)  /alpha   (alpha)   /beta (beta)
  /Gamma    (gamma)   /Delta  (delta)  /epsilon (epsilon) /eta  (eta)
  /Theta    (theta)   /Lambda (lambda) /mu      (mu)      /Xi   (xi)
  /Pi       (pi)      /rho    (rho)    /Sigma   (sigma)   /Phi  (phi)
  /Psi      (psi)     /Omega  (omega)  /at      (at)      /numbersign (hash)
  /percent  (percent) /cent   (cent)   /yen     (yen)     /Euro (euro)
  /currency (dollar)  /circleplus (oplus)     /dagger (dagger)   /daggerdbl (double-dagger)
  /section  (section) /paragraph  (paragraph) /diamond (diamond) /heart (heart)
>> def

0.5 0.75 position moveto
4 string stringwidth pop 90 2 mul add neg 0 rmoveto % goofy centering logic
gsave
0 1 31 {
  dup dup
  code2 exch get
  12 codexshow ( ) show
  gsave
    /Helvetica findfont 12 scalefont setfont
    code2 exch get pronunciation exch get show
  grestore
  90 0 rmoveto

  4 mod 3 eq {
    grestore 0 -20 rmoveto gsave
  } if
} for
grestore
pgsave restore
showpage

%****************************************************************
%*
%* Table of Contents
%*
%****************************************************************
%%Page: (v) 5
%%BeginPageSetup
/pgsave save def
%%EndPageSetup

/Helvetica-Bold findfont 18 scalefont setfont
pgsize aload pop 72 sub exch 2 div exch
moveto (Table of Contents) centreshow

[1 4] 0 setdash
/Helvetica findfont 14 scalefont setfont
/pagenum 1 def

<<
  /x 72 def
  /xnum pgsize aload pop pop 108 sub def
  /y pgsize aload pop exch pop 108 sub def
  /displaying false
  /tocOn true

  /stringtype {
    displaying tocOn and {
      % Section title
      x y moveto show
      % Horizontal line
      % For aligned dots we go out of our way to start the line on the right hand side.
      currentpoint xnum 5 sub y moveto lineto stroke
      % Page number
      xnum y moveto pagenum 2 string cvs show
      /y y 24 sub store
    } { pop } ifelse
  }
  /nametype {
    <<
      /section 1
      /endsection -1
      /subsection 2
      /endsubsection -2
      /subsubsection 3
      /endsubsubsection -3
    >> exch 2 copy known {
      get
      % For top-level sections bump y down an extra space
      dup 1 eq { /y y 15 sub store } if
      % For all sections just adjust x accordingly
      /x 1 index 20 mul x add store
      /displaying exch 0 gt store
    } {
      dup
      /notoc eq { /tocOn false store } if
      /toc eq { /tocOn true store } if
      pop
    } ifelse
  }
>> begin

allPageContent { % forall pages
  { % forall symbols in page
    dup type exec
  } forall
  /pagenum pagenum 1 add store
} forall

end

pgsave restore
showpage

%****************************************************************
%*
%* Main Content
%*
%****************************************************************
%%Page: 1 6
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
72 pgsize aload pop 36 sub exch pop allPageContent 0 get drawPageContent
pgsave restore showpage

%%Page: 2 7
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
72 pgsize aload pop 36 sub exch pop allPageContent 1 get drawPageContent
pgsave restore showpage

%%Page: 3 8
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
72 pgsize aload pop 36 sub exch pop allPageContent 2 get drawPageContent

72 320 drawDataFormat
pgsave restore showpage

%%Page: 4 9
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
72 pgsize aload pop 36 sub exch pop allPageContent 3 get drawPageContent

% Dice Worksheet
50 50 translate
10 dict begin
% tree
  /radius 0.705 72 mul 7 div def
  /spacing 50 def
  /coord { % i j -- x y
     1 index 2 exch exp exch 0.5 add mul 2 mul 1.1 radius mul mul
     exch 0.5 add spacing mul
  } bind def
  /trimedline { % x1 y1 x2 y2 --
  10 dict begin
    { /y2 /x2 /y1 /x1 } {exch def} forall
    /dx x2 x1 sub def
    /dy y2 y1 sub def
    /l dx dup mul dy dup mul add sqrt def
    x1 y1 moveto 0 dup dx mul exch dy mul rmoveto
    1 2 0 mul sub dup dx mul exch dy mul rlineto
  end
  } bind def
  1 1 5 {
    /i exch def
    0 1 2 5 i sub exp 1 sub {
      /j exch def
      /x 2 i exp j 0.5 add mul 2 mul 1.1 radius mul mul def
      i j coord moveto radius 5 div neg 0 rmoveto
      i j coord radius 5 div -180 180 arc
    } for
  } for
  thick line stroke
  0 1 4 {
    /i exch def
    0 1 2 5 i sub exp 1 sub {
      /j exch def
      /x 2 i exp j 0.5 add mul 2 mul 1.1 radius mul mul def
      i j coord i 1 add j 2 idiv coord trimedline
    } for
  } for
  thin line stroke
  /fontsz 20 def
  0 1 31 {
    /j exch def
    /x 1.1 radius mul 2 j mul 1 add mul def
    x spacing 2 div fontsz 0.3 mul sub 5 sub moveto
    code j get fontsz centrecodexshow
  } for
end
pgsave restore showpage

%%Page: 5 10
%%PageOrientation: Landscape
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
90 rotate

% Font for the numeric labels on the dice pads
/Helvetica-Bold findfont 14 scalefont setfont
% Characteristic size of the pads: equal to a side length for the square
% pads, and 5/9 the side length for the hexagonal ones. (There is no good
% mathematical reason for 5/9, it just fit the space requirements.)
/sz 54 def

86 -108 moveto
1 1 5 {
  /dieIdx exch def

  gsave
    % Draw label line
    gsave
      -4 sz 2 sqrt div add sz 2 sqrt div rmoveto
      -40 sz 2 sqrt div sub 0 rlineto stroke
    grestore
    % Draw six squares
    1 1 6 {
      /idx exch def
      /sz2 sz 2 sqrt div def

      % square
      gsave
        sz2 sz2 rlineto
        sz2 sz2 neg rlineto
        sz2 neg sz2 neg rlineto
        closepath gsave 0.95 setgray fill grestore stroke
      grestore
      % label
      gsave sz2 -6 rmoveto idx 2 string cvs centreshow grestore
      % move to origin for next iteration
      idx 2 mod 0 eq {
        sz2 sz2 neg rmoveto
        2 -2 rmoveto % add small gap
      } {
        sz2 sz2 rmoveto
        2 2 rmoveto % add small gap
      } ifelse
    } for

    % offset origin before starting hexagons, in an ad-hoc way
    sz2 2.5 div dup neg rmoveto

    % Draw 14 hexagons
    7 1 20 {
      /idx exch def
      /sz2 sz 1.8 div def % ad-hoc size adjustment

      % hexagon
      gsave
        0 sz2 rlineto
        sz2 3 sqrt mul 2 div sz2 2 div rlineto
        sz2 3 sqrt mul 2 div sz2 2 div neg rlineto
        0 sz2 neg rlineto
        sz2 3 sqrt mul 2 div neg sz2 2 div neg rlineto
        closepath gsave 0.95 setgray fill grestore stroke
      grestore
      % label
      gsave
        sz2 3 sqrt mul 2 div sz2 2 div 8 sub rmoveto
        idx 2 string cvs centreshow
      grestore
      % move to origin for next iteration
      idx 2 mod 0 eq {
        0 sz2 neg rmoveto
        sz2 3 sqrt mul 2 div sz2 2 div neg rmoveto
      } {
        0 sz2 rmoveto
        sz2 3 sqrt mul 2 div sz2 2 div rmoveto
      } ifelse
    } for
  grestore

  % Move to next row
  0 -105 rmoveto
} for

pgsave restore showpage

%%Page: 6 11
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
72 pgsize aload pop 36 sub exch pop allPageContent 4 get drawPageContent

% EDITME
% Edit these values to draw tables for larger k. Be warned that the total work to recover
% a secret from k shares will be on the other of (48 + k - 1)k volvelle applications. For
% k = 8 this is already over 250. And this is not even considering the logistics of keeping
% eight distributed shares intact and available..
/mink 2 def
/maxk 6 def

/x 104 def
/y 460 def
/rowtitle 6 string def
mink 1 maxk {
  /k exch def

  0 1 k {
    /rowidx exch def
    x y moveto
    /Courier-Bold findfont 12 scalefont setfont
    rowidx 0 eq {
      % First row (heading)
      k (k =   ) rowtitle copy 4 2 getinterval cvs pop
      rowtitle show

      k mink sub { 12 0 rmoveto } repeat
      k 1 31 {
        permS exch get code exch get gsave glyphshow grestore
        12 0 rmoveto
      } for % horizontal loop
    } {
      % Symbol rows
      /xinterp rowidx 1 sub def % x coord to interpolate at
      (  ) show
      permS xinterp get code exch get glyphshow
      (   ) show

      k mink sub { 12 0 rmoveto } repeat
      k 1 31 {
        permS exch get  % x coord to evaluate at
        permS xinterp get % x coord to interpolate at
        permS 0 k getinterval % x coords to interpolate at
        lagrange % symbol
        code2 exch get gsave 12 codexshow grestore % print symbol
        12 0 rmoveto
      } for % horizontal loop
    } ifelse

    /y y 11 sub def
  } for % vertical loop
  /y y 20 sub def
} for
pgsave restore showpage

%%Page: 7 12
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
72 pgsize aload pop 36 sub exch pop allPageContent 5 get drawPageContent
pgsave restore showpage

%%Page: 8 13
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
72 pgsize aload pop 36 sub exch pop allPageContent 6 get drawPageContent
pgsave restore showpage

%%Page: 9 14
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
{xor} (Addition) code dup perm drawBottomWheelPage

pgsave restore
showpage
%%Page: 10 15
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
showTopWheelPage

pgsave restore
showpage
%%Page: 11 16
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
% gsave verythin line marginpath stroke grestore
recoveryDisc begin
% Draw assembly diagram
10 dict begin
/yscale 0.25 def
/pinoffset -55 def
gsave
  120 700 translate
  0.4 dup scale
    % pin size is the width of the cross
   0 pinoffset neg moveto 4.5 2 mul drawPin
  gsave
    0 pinoffset neg moveto 0 0 lineto
    [4.5 4.5] 4.5 1.5 mul setdash stroke
  grestore
  matrix currentmatrix
    1 yscale scale
    -90 rotate
    drawTopDisc
    newpath 0 0 innerRadius 360 0 arcn
  setmatrix
  0 -60 translate
  matrix currentmatrix
    1 yscale scale
    0 0 radius 2 mul 0 360 arc clip
    drawBottomDisc
  setmatrix
  gsave
    0 pinoffset neg moveto 0 0 lineto
    [4.5 4.5] 4.5 1.5 mul setdash stroke
  grestore
grestore
end
% Move cursor to center of page
pgsize aload pop 2 div exch 2 div exch translate
% angle the page
  /pageangle pgsize aload pop radius angleinbox def
  /buffer 2 def
  pageangle rotate
  gsave
    0 buffer innerRadius add neg translate
    drawBottomDisc
  grestore
  0 buffer radius add translate
  90 pageangle sub rotate
  drawTopDisc
end
pgsave restore
showpage
%%Page: 12 17
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
% gsave verythin line marginpath stroke grestore
% Draw assembly diagram
gsave
  60 700 translate
  0.4 dup scale
  0 0 70 90 180 5 copy 5 copy
  arc
  pop -10 arrowHeadPath
  exch pop 10 arrowHeadPath
  5 line stroke
  5 75 foldingBottomDiscs
grestore
gsave
  140 600 translate
  0.4 dup scale
  multiplicationDisc begin
    0 0 radius 2 mul 255 260 5 copy arc
    exch pop 10 arrowHeadPath 5 line stroke
    0 0 radius 2 mul 280 275 5 copy arcn
    exch pop -10 arrowHeadPath 5 line stroke
  end
  5 175 foldingBottomDiscs
grestore
/Helvetica findfont 14 scalefont setfont
20 740 moveto (1.) show
95 600 moveto (2.) show
% Move cursor to center of page
pgsize aload pop 2 div exch 2 div exch translate
% angle the page
multiplicationDisc begin
  pgsize aload pop bottomfoldline angleinbox rotate
gsave
   newpath
   radius 1.1 mul 0 moveto
   radius 1.1 mul neg 0 lineto
   radius 1.1 mul neg radius -2.2 mul lineto
   radius 1.1 mul radius -2.2 mul lineto
   closepath
   clip
   0 bottomfoldline neg translate
   drawBottomDisc
grestore
end
180 rotate
translationDisc begin
   newpath
   radius 1.1 mul 0 moveto
   radius 1.1 mul neg 0 lineto
   radius 1.1 mul neg radius -2.2 mul lineto
   radius 1.1 mul radius -2.2 mul lineto
   closepath
   clip
   0 bottomfoldline neg translate
   drawBottomDisc
end

pgsave restore
showpage
%%Page: 13 18
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
% gsave verythin line marginpath stroke grestore
% Draw assembly diagram
gsave
  60 700 translate
  0.4 dup scale
  0 0 70 90 180 5 copy 5 copy
  arc
  pop -10 arrowHeadPath
  exch pop 10 arrowHeadPath
  5 line stroke
  matrix currentmatrix
    75 foldprojection concat
    translationDisc begin
      0 topfoldline translate
      180 rotate
      drawTopDisc
    end
  dup setmatrix
    multiplicationDisc begin
      40 bottomfoldline topfoldline sub translate
    end
    1 179 foldingBottomDiscs
  setmatrix
  5 foldprojection concat
  multiplicationDisc begin
    0 topfoldline neg translate
    gsave
      newpath outlineTopDisc 1 setgray fill
    grestore
    drawTopDisc
  end
grestore
gsave
  170 600 translate
  0.4 dup scale
  multiplicationDisc begin
    0 0 radius 2 mul 255 260 5 copy arc
    exch pop 10 arrowHeadPath 5 line stroke
    0 0 radius 2 mul 280 275 5 copy arcn
    exch pop -10 arrowHeadPath 5 line stroke
  end
  matrix currentmatrix
    175 foldprojection concat
    translationDisc begin
      0 topfoldline translate
      180 rotate
      newpath outlineTopDisc verythin line resetstroke
    end
  dup setmatrix
    multiplicationDisc begin
      0 bottomfoldline topfoldline sub translate
    end
    1 179 foldingBottomDiscs
  setmatrix
  5 foldprojection concat
  multiplicationDisc begin
    0 topfoldline neg translate
    gsave
      newpath outlineTopDisc 1 setgray fill
    grestore
    drawTopDisc
  end
grestore
gsave
  500 230 translate
  0.4 dup scale
  matrix currentmatrix
  multiplicationDisc begin
    90 rotate
    matrix currentmatrix
      0 topfoldline translate [1 0 2 tan 1 0 0] concat 0 topfoldline neg translate
      0.25 1 scale
      newpath outlineTopDisc verythin line resetstroke
    setmatrix
    matrix currentmatrix
      0.25 1 scale
      gsave newpath outlineBottomDisc 1 setgray fill grestore
      drawBottomDisc
    setmatrix
    0 topfoldline translate [1 0 -1 tan 1 0 0] concat 0 topfoldline neg translate
    0.25 1 scale
    gsave newpath outlineTopDisc 1 setgray fill grestore
    drawTopDisc
    0 0 moveto
  end
  setmatrix
  0 55 lineto
  [4.5 4.5] 0 setdash stroke
  0 55 moveto 4.5 2 mul drawPin
grestore
gsave
  500 100 translate
  0.4 dup scale
  translationDisc begin
    drawBottomDisc
    gsave
      newpath outlineTopDisc 1 setgray fill
    grestore
    drawTopDisc
    90 rotate
    0 0 moveto 4.5 2 mul drawSplitPin
  end
grestore
/Helvetica findfont 14 scalefont setfont
20 740 moveto (3.) show
125 600 moveto (4.) show
410 260 moveto (5.) show
410 175 moveto (6.) show
% Move cursor to center of page
pgsize aload pop 2 div exch 2 div exch translate
% angle the page
multiplicationDisc begin
  pgsize aload pop topfoldline angleinbox rotate
gsave
  0 topfoldline neg translate
  drawTopDisc
grestore
180 rotate
translationDisc begin
  0 topfoldline neg translate
  drawTopDisc
end

pgsave restore
showpage
%%Page: 14 19
%%PageOrientation: Landscape
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
90 rotate 0 -750 translate

/Helvetica-Bold findfont 10 scalefont setfont
pgsize aload pop exch pop 2 div 700
moveto (ms32 Checksum Table) centreshow

/drawTable {
  10 dict begin
  { /startVal /tHeight /tWidth /y /x } {exch def} forall

  /cellH tHeight 32 div def
  /cellW tWidth 8 div def

  % Draw horizontal background lines: one black one for the heading then
  % alternating 4-cell-height white/gray for the content background
  x y moveto
  0 1 31 {
    dup 0 eq { 0.8 } {
      8 mod 4 lt { 0.8 } { 1 } ifelse
    } ifelse setgray

    gsave
      tWidth 0 rlineto
      0 cellH neg rlineto tWidth neg 0 rlineto closepath fill
    grestore
    0 cellH neg rmoveto
  } for

  % Draw vertical background lines: one double-wide black one per column
  x y moveto
  0 1 7 {
    1 setgray
    gsave
      0 tHeight neg rlineto
      cellW 26 div neg 0 rlineto 0 tHeight rlineto closepath fill
    grestore
    0 setgray
    gsave
      0 tHeight neg rlineto
      cellW 2 mul 13 div 0 rlineto 0 tHeight rlineto closepath fill
    grestore
    cellW 0 rmoveto
  } for

  % Draw content
  startVal 1 startVal 7 add {
    /xVal exch def
    x xVal startVal sub cellW mul add 2 add y 1.5 add moveto
    0 1 31 {
      /yVal exch def
      0 cellH neg rmoveto

      gsave
        /Courier-Bold findfont 8.5 scalefont setfont
        1 setgray
        code perm xVal get get glyphshow
        code perm yVal get get glyphshow
      grestore

      gsave
        cellW 2 mul 13 div 0 rmoveto
        perm xVal get perm yVal get polymodshift2 {
          code exch get glyphshow
          0.25 0 rmoveto
        } forall
      grestore
    } for
  } for

  % Bounding box
  0.5 setlinewidth
  x y moveto
  0 tHeight neg rlineto
  tWidth 0 rlineto
  0 tHeight rlineto
  closepath stroke

  end
} bind def

/Courier findfont 8.5 scalefont setfont
36 pgsize aload pop exch pop 104 sub
pgsize aload pop 72 sub exch 108 sub 2 div
0 drawTable

36 pgsize aload pop exch pop 2 div 32 add
pgsize aload pop 72 sub exch 108 sub 2 div
8 drawTable

false {
0 1 15 {
  /xidx exch def
  0 1 31 {
    /yidx exch def
    yidx 2 mod 0 eq {0.5 0.2 0.0} {0 0 0} ifelse setrgbcolor

    % Position for bold letters
    xidx 8 mod 90 mul 30 add
    680 yidx 7.5 mul sub xidx 8 idiv 270 mul sub
    moveto

    % Display bold letters
    gsave
      /Courier-Bold findfont 8.5 scalefont setfont
      code perm xidx get get glyphshow
      code perm yidx get get glyphshow
    grestore

    % Compute and display "checksum table" entry which is checksum of AB00...00
    12 0 rmoveto
    perm xidx get perm yidx get polymodshift2
    % Draw it
    0 1 polymodulus length 1 sub {
      1 index exch get % value from polymod
      code exch get glyphshow
    } for
    pop
  } for
} for
} if

pgsave restore
showpage
%%Page: 15 20
%%PageOrientation: Landscape
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
90 rotate 0 -750 translate

/Helvetica-Bold findfont 10 scalefont setfont
pgsize aload pop exch pop 2 div 700
moveto (ms32 Checksum Table) centreshow

/drawTable {
  10 dict begin
  { /startVal /tHeight /tWidth /y /x } {exch def} forall

  /cellH tHeight 32 div def
  /cellW tWidth 8 div def

  % Draw horizontal background lines: one black one for the heading then
  % alternating 4-cell-height white/gray for the content background
  x y moveto
  0 1 31 {
    dup 0 eq { 0.8 } {
      8 mod 4 lt { 0.8 } { 1 } ifelse
    } ifelse setgray

    gsave
      tWidth 0 rlineto
      0 cellH neg rlineto tWidth neg 0 rlineto closepath fill
    grestore
    0 cellH neg rmoveto
  } for

  % Draw vertical background lines: one double-wide black one per column
  x y moveto
  0 1 7 {
    1 setgray
    gsave
      0 tHeight neg rlineto
      cellW 26 div neg 0 rlineto 0 tHeight rlineto closepath fill
    grestore
    0 setgray
    gsave
      0 tHeight neg rlineto
      cellW 2 mul 13 div 0 rlineto 0 tHeight rlineto closepath fill
    grestore
    cellW 0 rmoveto
  } for

  % Draw content
  startVal 1 startVal 7 add {
    /xVal exch def
    x xVal startVal sub cellW mul add 2 add y 1.5 add moveto
    0 1 31 {
      /yVal exch def
      0 cellH neg rmoveto

      gsave
        /Courier-Bold findfont 8.5 scalefont setfont
        1 setgray
        code perm xVal get get glyphshow
        code perm yVal get get glyphshow
      grestore

      gsave
        cellW 2 mul 13 div 0 rmoveto
        perm xVal get perm yVal get polymodshift2 {
          code exch get glyphshow
          0.25 0 rmoveto
        } forall
      grestore
    } for
  } for

  % Bounding box
  0.5 setlinewidth
  x y moveto
  0 tHeight neg rlineto
  tWidth 0 rlineto
  0 tHeight rlineto
  closepath stroke

  end
} bind def

/Courier findfont 8.5 scalefont setfont
36 pgsize aload pop exch pop 104 sub
pgsize aload pop 72 sub exch 108 sub 2 div
16 drawTable

36 pgsize aload pop exch pop 2 div 32 add
pgsize aload pop 72 sub exch 108 sub 2 div
24 drawTable

false {
0 1 15 {
  /xidx exch def
  0 1 31 {
    /yidx exch def
    yidx 2 mod 0 eq {0.5 0.2 0.0} {0 0 0} ifelse setrgbcolor

    % Position for bold letters
    xidx 8 mod 90 mul 30 add
    680 yidx 7.5 mul sub xidx 8 idiv 270 mul sub
    moveto

    % Display bold letters
    gsave
      /Courier-Bold findfont 8.5 scalefont setfont
      code perm xidx get get glyphshow
      code perm yidx get get glyphshow
    grestore

    % Compute and display "checksum table" entry which is checksum of AB00...00
    12 0 rmoveto
    perm xidx get perm yidx get polymodshift2
    % Draw it
    0 1 polymodulus length 1 sub {
      1 index exch get % value from polymod
      code exch get glyphshow
    } for
    pop
  } for
} for
} if

pgsave restore
showpage
%%Page: 16 21
%%PageOrientation: Landscape
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
90 rotate 0 -750 translate
/hrp (ms) def

/labeledbox {
  10 dict begin
  { /beginred /n } {exch def} forall
  /n n hrp length add 2 add def
  gsave
    n beginred thick box
  grestore
  gsave
    arraySpace 6 sub 14 5 sub rmoveto
    /Courier findfont 3 scalefont setfont
    n 10 le { ( ) show } if n 2 string cvs show
  grestore
  end
} bind def
/Helvetica-Bold findfont 10 scalefont setfont
pgsize aload pop exch pop 2 div 700
moveto (ms32 Checksum Worksheet) centreshow


120 670
% [10 29 19 13 4 16 20 8 16 7 4 13 6 8 27 31 28 14 17 21 31 25 19 15 1 3 13 29 22 5 8 31 9 17 15 30 19 15 21 16 19 26 16 22 31]
[ 45 {32} repeat ]
10 dict begin
{ /codeword /y /x } {exch def} forall
/Courier findfont 15 scalefont setfont
x y moveto hrp (1) concatstrings dup stringwidth pop neg 3 sub 0 rmoveto show
/odd polymodulus length codeword length add 2 mod def
/edge codeword length polymodulus length sub hrp length add 2 add def
/gaps [ 0 1 codeword length { 4 mod 1 eq {gapSpace} {arraySpace} ifelse } for ] def
/k polymodulus length odd sub def
  {edge labeledbox} x arraySpace odd mul add y moveto codeword gaps 1 k getinterval 0 showArrayBox
/y y 14 sub def
/reduction [hrp polymodhrp aload pop k {0} repeat ] polymod0 def
  {reduction length thin box} x arraySpace odd mul add y moveto reduction gaps 1 k getinterval odd showArrayBox
/y y 15 sub def
/residue reduction [1 odd eq {0} if codeword 0 k getinterval aload pop ] gf32addarray def

{
  k codeword length ge {exit} if
  { codeword length k sub thin box} x y moveto residue gaps k 1 add residue length sub residue length getinterval 0 showArrayBox
  {edge labeledbox} codeword gaps k 1 add 2 getinterval k showArrayBox
  /x x gaps k 1 add reduction length sub 2 getinterval aload pop add add def
  /y y 14 sub def
  /reduction residue 0 2 getinterval aload pop polymodshift2 def
  {reduction length thin box} x y moveto reduction gaps k 1 add reduction length 2 sub sub reduction length getinterval 0 showArrayBox
  /y y 15 sub def
  /residue reduction [residue 2 polymodulus length 2 sub getinterval aload pop codeword k 2 getinterval aload pop] gf32addarray def
  /k k 2 add def
} loop

gsave 0.85 setgray x y moveto checksum gaps k 1 add residue length sub residue length getinterval 0 showArray grestore
{residue length thin box} x y moveto residue gaps k 1 add residue length sub residue length getinterval 0 showArrayBox


end

100 420 moveto
/Helvetica-Bold findfont 10 scalefont setfont
(Verifying Checksums) show
100 400 moveto
/Helvetica findfont 9 scalefont setfont
(Write out the 45 character data portion in the) show
100 390 moveto
(bold boxes, two at a time, starting on the top) show
100 380 moveto
(row.  Working from the top row down, look up) show
100 370 moveto
(the first two characters of each odd row in the) show
100 360 moveto
(ms32 Checksum Table and write the ) polymodulus length 10 string cvs concatstrings show
100 350 moveto
(character word into the even row below it.  Fill) show
100 340 moveto
(in the odd rows by adding the two characters) show
100 330 moveto
(above each cell.  You may use either the) show
100 320 moveto
(addition wheel table.  The first few boxes are) show
100 310 moveto
(already filled in for you.  The last row will sum) show
100 300 moveto
(to ) show checksumstring {glyphshow} forall ( if the checksum is valid.) show
100 260 moveto
/Helvetica-Bold findfont 10 scalefont setfont
(Creating Checksums) show
100 240 moveto
/Helvetica findfont 9 scalefont setfont
(Follow the "Verifying Checksums" instructions) show
100 230 moveto
(to fill in everything but the shaded cells. To fill in) show
100 220 moveto
(the shaded cells, write ) show checksumstring {glyphshow} forall ( into the bottom) show
100 210 moveto
(row.  Working from the bottom up, fill in the) show
100 200 moveto
(shaded cells by adding the two characters below) show
100 190 moveto
(each cell.  The ) polymodulus length 10 string cvs ( characters in the bold shaded) concatstrings concatstrings show
100 180 moveto
(boxes will be the checksum.) show

450 650
/offsety exch def
/offsetx exch def
/Courier findfont 10 scalefont setfont
20 offsetx add offsety moveto (Addition Table) show
/Courier-Bold findfont 8 scalefont setfont
0 1 31 {
dup 2 add 7 mul offsetx add offsety 10 sub moveto
perm exch get
code exch get glyphshow
} for

0 1 31 {
/Courier-Bold findfont 8 scalefont setfont
offsetx 34.5 7 mul add offsety 20 sub 2 index 8 mul sub moveto
dup code exch perm exch get get glyphshow
/Courier findfont 8 scalefont setfont
dup 1 31 {
dup 2 add 7 mul offsetx add offsety 20 sub 3 index 8 mul sub moveto
perm exch get
perm 2 index get gf32add code exch get glyphshow
} for pop } for

pgsave restore
showpage

%%Page: 17 22
%%PageOrientation: Landscape
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
  10 dict begin
  gsave

  90 rotate 0 -750 translate
  /Helvetica-Bold findfont 10 scalefont setfont
  pgsize aload pop exch pop 2 div 700
  moveto (Addition Worksheet \(k = 2\)) centreshow

  /labeledbox {
    10 dict begin
    /n exch 1 add def
    gsave
      n 1000 0.2 box
    grestore
    gsave
      arraySpace 6 sub 14 5 sub rmoveto
     /Courier findfont 3 scalefont setfont
      n 10 le { ( ) show } if n 2 string cvs show
    grestore
    end
  } bind def

  /drawRow {
    10 dict begin
    { /hrp /y /x } { exch def } forall
      x y moveto hrp dup stringwidth pop neg 3 sub 0 rmoveto show
      /k 3 def

      /init k k 4 mod sub 4 add k sub def
      {labeledbox} x y moveto [] [] init showBox
%      /x x init 0.25 add arraySpace mul add def
      /k k init add def
      {
        k 48 ge {exit} if

        {labeledbox} x y moveto [] [ 4 {arraySpace} repeat ] k 1 sub showBox

        /x x 4.25 arraySpace mul add def
        /k k 4 add def
    } loop
    end
  } bind def

  /x 96 def
  /y 675 def
  % Every other row-pair
  8 {
  % Initial row-pair which includes the "ms1" text
  x y (ms1) drawRow
  /y y 14 sub def
  x y (+ ms1) drawRow
 /y y 20 sub def
    x y (= ms1) drawRow
    /y y 32 sub def
  } repeat
end

pgsave restore
showpage

%%Page: 18 23
%%PageOrientation: Landscape
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
  10 dict begin
  gsave

  90 rotate 0 -750 translate
  /Helvetica-Bold findfont 10 scalefont setfont
  pgsize aload pop exch pop 2 div 700
  moveto (Addition Worksheet \(k = 3\)) centreshow

  /labeledbox {
    10 dict begin
    /n exch 1 add def
    gsave
      n 1000 0.2 box
    grestore
    gsave
      arraySpace 6 sub 14 5 sub rmoveto
     /Courier findfont 3 scalefont setfont
      n 10 le { ( ) show } if n 2 string cvs show
    grestore
    end
  } bind def

  /drawRow {
    10 dict begin
    { /hrp /y /x } { exch def } forall
      x y moveto hrp dup stringwidth pop neg 3 sub 0 rmoveto show
      /k 3 def

      /init k k 4 mod sub 4 add k sub def
      {labeledbox} x y moveto [] [] init showBox
%      /x x init 0.25 add arraySpace mul add def
      /k k init add def
      {
        k 48 ge {exit} if

        {labeledbox} x y moveto [] [ 4 {arraySpace} repeat ] k 1 sub showBox

        /x x 4.25 arraySpace mul add def
        /k k 4 add def
    } loop
    end
  } bind def

  /x 96 def
  /y 675 def
  % Every other row-pair
  5 {
  % Initial row-pair which includes the "ms1" text
  x y (ms1) drawRow
  /y y 14 sub def
  x y (+ ms1) drawRow
  /y y 20 sub def
    x y (= ms1) drawRow
  /y y 14 sub def
  x y (+ ms1) drawRow
 /y y 20 sub def
    x y (= ms1) drawRow
    /y y 32 sub def
  } repeat
end

pgsave restore
showpage

%%Page: 19 24
%%PageOrientation: Landscape
%%BeginPageSetup
/pgsave save def
%%EndPageSetup
  10 dict begin
  gsave

  90 rotate 0 -750 translate
  /Helvetica-Bold findfont 10 scalefont setfont
  pgsize aload pop exch pop 2 div 700
  moveto (Addition Worksheet \(extra\)) centreshow

  /labeledbox {
    10 dict begin
    /n exch 1 add def
    gsave
      n 1000 0.2 box
    grestore
    gsave
      arraySpace 6 sub 14 5 sub rmoveto
     /Courier findfont 3 scalefont setfont
      n 10 le { ( ) show } if n 2 string cvs show
    grestore
    end
  } bind def

  /drawRow {
    10 dict begin
    { /hrp /y /x } { exch def } forall
      x y moveto hrp dup stringwidth pop neg 3 sub 0 rmoveto show
      /k 3 def

      /init k k 4 mod sub 4 add k sub def
      {labeledbox} x y moveto [] [] init showBox
%      /x x init 0.25 add arraySpace mul add def
      /k k init add def
      {
        k 48 ge {exit} if

        {labeledbox} x y moveto [] [ 4 {arraySpace} repeat ] k 1 sub showBox

        /x x 4.25 arraySpace mul add def
        /k k 4 add def
    } loop
    end
  } bind def

  /x 96 def
  /y 675 def

  x y (ms1) drawRow
  /y y 14 sub def
  x y ( ) drawRow
  /y y 20 sub def
  % Every other row-pair
  14 {
  % Initial row-pair which includes the "ms1" text
  x y ( ) drawRow
  /y y 14 sub def
  x y ( ) drawRow
  /y y 20 sub def
  } repeat
end

pgsave restore
showpage
%%EOF
